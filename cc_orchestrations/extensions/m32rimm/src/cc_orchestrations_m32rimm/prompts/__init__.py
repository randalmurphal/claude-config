"""m32rimm-specific prompt additions and overrides.

These prompts add MongoDB, import framework, and BO-specific context
to the base orchestration prompts.
"""

# Additional context to inject into base prompts
MONGO_CONTEXT = """
## MongoDB Patterns (m32rimm)

**ALWAYS use `fisio.common.mongo_helpers`:**
- `retry_run(func, *args)` - Wrap ALL mongo writes for retry on connection failure
- `DBOpsHelper` - Auto-batching for bulk ops (MUST call `.flush()` before aggregating)
- `find_one_or_none()` - Safe queries

**Multi-tenancy (CRITICAL):**
- ALL `businessObjects` queries MUST filter by `info.owner.subID`
- Security isolation between subscriptions - missing filter = data leak

**Date/Time:**
- ALWAYS use `get_utc_now(naive=True)` from `fisio.common.date_utils` for MongoDB storage
- MongoDB requires naive datetimes (no timezone info)
- NEVER use raw `datetime.now()` or `datetime.utcnow()`

**Multiprocessing/Threading:**
- Each process/worker needs its OWN MongoDB connection (can't share pymongo across processes)
- Same applies to Redis and other network resources
"""

IMPORT_CONTEXT = """
## Import Framework Patterns (m32rimm)

**Pattern:** Initialize → Fetch → Transform → Upsert → Flush → Aggregate → Complete

**Key utilities:**
- `DBOpsHelper` for batching (remember to `.flush()` before aggregation)
- `MixinParallelDataProcessing` for multiprocessing (separate DB connections per worker)
- `mark_for_aggregation(bo_type)` builds dict, `call_clustereng_tps_owasp_aggs()` triggers

**Import tracking (data_importer):**
- NOT required for all imports - only when audit trail needed
- Pattern: `insert_data_importer()` at start, `complete_data_importer()` at end
- Check `data_imports` collection for job status

**Aggregation triggering:**
- MUST call `db_ops_helper.flush()` BEFORE triggering aggregation
- Missing flush = aggregation runs against stale/missing data
"""

BO_CONTEXT = """
## Business Object Patterns (m32rimm)

**All BOs in single `businessObjects` collection:**
- 30 BO types, identified by `md.type`
- Structure: `md` (metadata), `info` (core), `data` (type-specific), `related`/`relatedV2`

**toolIDs structure:**
- `data.toolIDs` is a LIST of objects: `[{toolName: "X", id: "Y", url: "Z"}]`
- Query pattern: `{'data.toolIDs.toolName': 'Tenable SC', 'data.toolIDs.id': ext_id}`

**Selectizer lookup order:**
- Check sub_id first, fallback to global (subID: None) unless `only_sub_selectizer=True`
- Use `get_selectizer_doc()` or `find_selectizer_smart()` which handle this

**Activities:**
- Stored in dedicated `activities` collection (not BO arrays)
- DBOpsHelper automatically reroutes activity records when writing to businessObjects

**Relationships:**
- `related.*` - Simple ID arrays for basic parent-child relationships
- `relatedV2` - Rich relationship objects with metadata, types, timestamps
- Aggregation lookups use `related.*`, relatedV2 is pass-through

**Gotchas:**
- NO universal fingerprint field - deduplication varies by BO type
- Grid collections are regenerated by aggregation - don't manually edit
"""

# Override or extend specific prompts
PROMPTS = {
    # These will be merged with base prompts
    # Keys match base prompt names
}


def get_full_context() -> str:
    """Get full m32rimm context for injection into prompts."""
    return f"""
{MONGO_CONTEXT}

{IMPORT_CONTEXT}

{BO_CONTEXT}
"""


__all__ = [
    'BO_CONTEXT',
    'IMPORT_CONTEXT',
    'MONGO_CONTEXT',
    'PROMPTS',
    'get_full_context',
]
