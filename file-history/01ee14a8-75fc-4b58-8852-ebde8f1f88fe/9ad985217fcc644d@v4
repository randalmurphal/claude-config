# Orchestration MCP - Simple Usage Guide

Cut through the bullshit. Here's what actually works.

## TL;DR: The Core API

```python
# 1. Start task (system detects complexity automatically)
start_task(
    description="What you're building",
    working_directory="/path/to/project",
    complexity="medium"  # Options: "simple", "medium", "complex", "massive"
)
# Returns: {"task_id": "uuid", "complexity": "medium", "workflow": {...}}

# 2. Prepare phase
prepare_phase(task_id="uuid", phase="skeleton")
# Returns: Agent contexts and recommendations

# 3. Work happens (agents do their thing)

# 4. Finalize phase (NOW RUNS REAL VALIDATION!)
finalize_phase(task_id="uuid", phase="skeleton")
# Returns: {"passed": true/false, "checkpoint_id": "abc123", "can_proceed": true/false}

# 5. Record decisions
record_phase_result(
    task_id="uuid",
    phase="skeleton",
    decisions=[{...}],
    gotchas=["..."]
)

# 6. Complete task
complete_task(task_id="uuid", summary="What you accomplished")
```

## What Changed from Previous Version

**Previous Issues:**
- Self-validation (finalize_phase asked "did tests pass?")
- No real checkpoints (couldn't recover)
- 15 phantom tools documented but not implemented

**Current Version:**
- **REAL validation** - Actually runs pytest/ruff/imports
- **Git checkpoints** - Rollback on failures
- **Parallel work** - Git worktrees with smart merging
- **Complexity scaling** - Adapts workflow to task size
- **21 working tools** - All implemented and tested

## Validation Examples (NEW!)

### Validate a Phase

```python
# Run actual validation (pytest/ruff/imports)
result = await mcp__orchestration__validate_phase(
    task_id="task_abc123",
    phase="implementation",
    working_directory="/path/to/project"
)

# Response when tests PASS:
{
    "passed": True,
    "can_proceed": True,
    "checks": {
        "imports": {"passed": True, "errors": []},
        "pytest": {
            "passed": True,
            "failed_tests": [],
            "coverage": 0.94,
            "total_tests": 156,
            "passed_tests": 156
        },
        "linting": {"passed": True, "issues": []}
    },
    "suggestion": "All checks passed. Ready to proceed."
}

# Response when tests FAIL:
{
    "passed": False,
    "can_proceed": False,
    "checks": {
        "pytest": {
            "passed": False,
            "failed_tests": ["test_auth.py::test_login"],
            "coverage": 0.87,
            "message": "1 test failed, coverage below 90%"
        }
    },
    "suggestion": "Fix failing test in test_auth.py::test_login and improve coverage to 90%+"
}
```

## Checkpoint Examples (NEW!)

### Create Checkpoint

```python
# Auto-created during finalize_phase, but can be manually created
result = await mcp__orchestration__create_checkpoint(
    task_id="task_abc123",
    phase="skeleton",
    working_directory="/path/to/project",
    validation_passed=True
)

# Response:
{
    "checkpoint_id": "a1b2c3d4e5f6",  # git SHA
    "phase": "skeleton",
    "timestamp": "2025-09-29T21:45:00Z",
    "files_changed": 15
}
```

### List Checkpoints

```python
result = await mcp__orchestration__list_checkpoints(
    task_id="task_abc123",
    working_directory="/path/to/project"
)

# Response:
{
    "checkpoints": [
        {
            "checkpoint_id": "a1b2c3d",
            "phase": "skeleton",
            "timestamp": "2025-09-29T20:00:00Z",
            "validation_passed": True,
            "files_changed": 15
        },
        {
            "checkpoint_id": "e5f6g7h",
            "phase": "implementation",
            "timestamp": "2025-09-29T21:30:00Z",
            "validation_passed": True,
            "files_changed": 42
        }
    ]
}
```

### Rollback to Checkpoint

```python
result = await mcp__orchestration__rollback_to_checkpoint(
    task_id="task_abc123",
    checkpoint_id="a1b2c3d",
    working_directory="/path/to/project"
)

# Response:
{
    "success": True,
    "checkpoint_id": "a1b2c3d",
    "phase": "skeleton",
    "message": "Rolled back to skeleton checkpoint"
}
```

## Worktree Examples (NEW!)

### Create Worktree

```python
result = await mcp__orchestration__create_worktree(
    task_id="task_abc123",
    module="auth",
    working_directory="/path/to/project"
)

# Response:
{
    "worktree_path": "/path/to/project/../worktree_auth",
    "module": "auth",
    "branch": "orchestration/task_abc123/auth"
}

# Agent works in worktree_path without conflicts
```

### Merge Worktrees

```python
result = await mcp__orchestration__merge_worktrees(
    task_id="task_abc123",
    modules=["auth", "cart", "payment"],
    working_directory="/path/to/project",
    strategy="smart"  # Options: first_wins, last_wins, smart, manual
)

# Response:
{
    "merged": ["auth", "cart", "payment"],
    "conflicts": [
        {
            "module": "cart",
            "file": "models/cart.py",
            "resolution_used": "smart (kept simpler version)"
        }
    ],
    "validation": {
        "passed": True,
        "issues": []
    }
}
```

## Complexity Analysis (NEW!)

### Analyze Task Complexity

```python
result = await mcp__orchestration__analyze_task_complexity(
    description="Refactor authentication system across multiple modules",
    working_directory="/path/to/project"
)

# Response:
{
    "complexity": "large",
    "estimated_files": 15,
    "estimated_duration": {"min_hours": 8, "max_hours": 20},
    "should_decompose": False,
    "parallel_recommended": True,
    "workflow": {
        "phases": ["architecture", "skeleton", "validate", "implementation", "testing", "integration"],
        "validation_gates": ["skeleton", "implementation", "integration"],
        "checkpoints": ["skeleton", "implementation", "testing"],
        "parallel_threshold": 2
    },
    "reasoning": "Keywords like 'refactor' and 'multiple modules' suggest large complexity..."
}
```

## Task Decomposition (NEW!)

### Decompose Massive Task

```python
result = await mcp__orchestration__decompose_task(
    task_id="master_abc123",
    description="Build complete e-commerce platform with auth, cart, payment, and admin",
    complexity_analysis={"complexity": "massive", "estimated_files": 50}
)

# Response:
{
    "subtasks": [
        {
            "subtask_id": "sub_1",
            "order": 1,
            "description": "Foundation: Data models and database schema",
            "depends_on": [],
            "estimated_files": 8,
            "estimated_duration_hours": 6
        },
        {
            "subtask_id": "sub_2",
            "order": 2,
            "description": "Authentication and user management",
            "depends_on": ["sub_1"],
            "estimated_files": 10,
            "estimated_duration_hours": 8
        },
        {
            "subtask_id": "sub_3",
            "order": 3,
            "description": "Shopping cart functionality",
            "depends_on": ["sub_1"],
            "estimated_files": 12,
            "estimated_duration_hours": 10
        }
    ],
    "total_subtasks": 5,
    "strategy": "vertical_slices",
    "integration_plan": "Build foundation first, then independent features in parallel, then admin dashboard"
}
```

### Get Next Subtask

```python
result = await mcp__orchestration__get_next_subtask(
    master_task_id="master_abc123"
)

# Response:
{
    "subtask": {
        "subtask_id": "sub_2",
        "description": "Authentication and user management",
        "depends_on": ["sub_1"],  # sub_1 completed
        "estimated_files": 10
    },
    "remaining": 4,
    "progress_percent": 20.0
}

# When all complete:
{
    "has_next": False,
    "remaining": 0,
    "progress_percent": 100.0
}
```

### Mark Subtask Complete

```python
result = await mcp__orchestration__mark_subtask_complete(
    master_task_id="master_abc123",
    subtask_id="sub_2",
    checkpoint_id="a1b2c3d"  # Checkpoint for this subtask
)

# Response:
{
    "completed": "sub_2",
    "checkpoint_id": "a1b2c3d",
    "next_subtask": {
        "subtask_id": "sub_3",
        "description": "Shopping cart functionality",
        "estimated_files": 12
    },
    "remaining": 3,
    "progress_percent": 40.0
}
```

## Intelligence Tools (Existing, Updated)

### Analyze Project

```python
result = await mcp__orchestration__analyze_project(
    working_directory="/path/to/project"
)

# Response:
{
    "language": "python",
    "frameworks": ["fastapi", "sqlalchemy"],
    "dependencies": {"fastapi": "0.104.1", "sqlalchemy": "2.0.23"},
    "suggested_files": ["models/user.py", "services/auth.py"],
    "gotchas": ["Use async with SQLAlchemy", "FastAPI depends() for DI"]
}
```

### Augment READY Spec

```python
result = await mcp__orchestration__augment_ready_spec(
    ready_file_path="/path/to/.prelude/READY.md",
    working_directory="/path/to/project"
)

# Adds auto-detected suggestions to READY.md
```

### Validate READY Spec

```python
result = await mcp__orchestration__validate_ready_spec(
    ready_file_path="/path/to/.prelude/READY.md"
)

# Response:
{
    "valid": True,
    "errors": [],
    "warnings": ["No custom roles defined"]
}
```

### Synthesize Learnings

```python
result = await mcp__orchestration__synthesize_learnings(
    task_id="task_abc123",
    working_directory="/path/to/project"
)

# Stores learnings to Neo4j and PRISM for future tasks
```

## Core Workflow Tools

### Start Task

```python
result = await mcp__orchestration__start_task(
    description="Implement user authentication with JWT",
    working_directory="/path/to/project",
    complexity="auto"  # or specify: small, medium, large, massive
)

# Response:
{
    "task_id": "abc123",
    "complexity": "medium",
    "workflow": {
        "phases": ["architecture", "skeleton", "implementation", "testing"],
        "validation_gates": ["skeleton", "implementation"],
        "checkpoints": ["skeleton", "implementation"]
    },
    "parallel_recommended": False
}
```

### Prepare Phase

```python
result = await mcp__orchestration__prepare_phase(
    task_id="abc123",
    phase="skeleton"
)

# Returns agent contexts and recommendations
```

### Finalize Phase (NOW WITH REAL VALIDATION!)

```python
# Current system: Actually runs validation
result = await mcp__orchestration__finalize_phase(
    task_id="abc123",
    phase="implementation"
)

# Response when validation PASSES:
{
    "status": "completed",
    "passed": True,
    "checkpoint_id": "e5f6g7h",
    "can_proceed": True,
    "validation": {
        "pytest": {"passed": True, "coverage": 0.94},
        "linting": {"passed": True},
        "imports": {"passed": True}
    }
}

# Response when validation FAILS:
{
    "status": "failed",
    "passed": False,
    "can_proceed": False,
    "validation": {
        "pytest": {
            "passed": False,
            "failed_tests": ["test_auth.py::test_login"]
        }
    },
    "suggestion": "Fix failing tests before proceeding"
}
```

### Record Phase Result

```python
result = await mcp__orchestration__record_phase_result(
    task_id="abc123",
    phase="skeleton",
    decisions=[{
        "question": "Which auth library?",
        "chosen": "python-jose",
        "rejected": ["pyjwt", "authlib"],
        "rationale": "Best FastAPI integration"
    }],
    gotchas=["JWT secret must be in env vars"]
)
```

### Complete Task

```python
result = await mcp__orchestration__complete_task(
    task_id="abc123",
    summary="Implemented JWT authentication with refresh tokens"
)

# Cleans up worktrees, stores learnings, clears Redis state
```

### Get Task Status

```python
result = await mcp__orchestration__get_task_status(
    task_id="abc123"
)

# Response:
{
    "task_id": "abc123",
    "current_phase": "implementation",
    "completed_phases": ["skeleton"],
    "checkpoints": ["a1b2c3d"],
    "worktrees": ["auth", "cart"]
}
```

### Parse READY Specification

```python
result = await mcp__orchestration__parse_ready_specification(
    ready_file_path="/path/to/.prelude/READY.md"
)

# Returns parsed READY.md sections
```

## Real Example That Works

```python
# Start
result = start_task(
    description="Build user authentication system",
    working_directory="/tmp/test",
    complexity="auto"
)
task_id = result["task_id"]  # Detected: "medium"

# Architecture phase
prepare_phase(task_id=task_id, phase="architecture")
# [agents plan modules]
finalize_phase(task_id=task_id, phase="architecture")

# Skeleton phase
prepare_phase(task_id=task_id, phase="skeleton")
# [agents build skeleton]
result = finalize_phase(task_id=task_id, phase="skeleton")
# System actually validates imports → CHECKPOINT created

# Implementation phase
prepare_phase(task_id=task_id, phase="implementation")
# [agents implement]
result = finalize_phase(task_id=task_id, phase="implementation")
# System runs pytest/ruff/imports → CHECKPOINT created

if not result["passed"]:
    # FIX TESTS
    # Re-run finalize_phase until it passes
    pass

# Record decisions
record_phase_result(
    task_id=task_id,
    phase="implementation",
    decisions=[{
        "question": "Password hashing?",
        "chosen": "bcrypt",
        "rejected": ["argon2", "pbkdf2"],
        "rationale": "Industry standard"
    }],
    gotchas=["Bcrypt is CPU-intensive, use asyncio.to_thread"]
)

# Done
complete_task(task_id=task_id, summary="Auth system complete with JWT")
```

## Common Mistakes

1. **Ignoring validation failures** - System blocks progression. Fix the tests!

2. **Not using checkpoints** - Checkpoints are automatic. Use rollback when needed.

3. **Trying to merge worktrees manually** - Use merge_worktrees tool instead.

4. **Skipping complexity analysis** - Let system detect and recommend workflow.

5. **Missing decision fields** - All 4 required: question, chosen, rejected, rationale

## What You Can Ignore

- READY.md specifications (optional, not required)
- PRISM integration (optional)
- Chamber management (automatic)
- Conflict detection (automatic if PRISM enabled)

## What You CANNOT Ignore

- **Validation failures** - System blocks progression until fixed
- **Checkpoints** - Automatic snapshots preserve your work
- **Complexity recommendations** - Workflows optimized per size
- **Worktree cleanup** - Use complete_task to clean up properly

## Tool Summary (21 Total)

**Core (7):** start_task, prepare_phase, finalize_phase, record_phase_result, complete_task, get_task_status, parse_ready_specification

**Validation (1):** validate_phase

**Checkpoints (3):** create_checkpoint, rollback_to_checkpoint, list_checkpoints

**Worktrees (2):** create_worktree, merge_worktrees

**Complexity (1):** analyze_task_complexity

**Decomposition (3):** decompose_task, get_next_subtask, mark_subtask_complete

**Intelligence (4):** analyze_project, augment_ready_spec, validate_ready_spec, synthesize_learnings

## Phases

Standard phases in order:
1. `architecture` - Plan modules and boundaries (medium/large/massive only)
2. `skeleton` - Create file structure and interfaces
3. `implementation` - Fill in the logic
4. `testing` - Write and run tests
5. `integration` - Test module interactions (large/massive only)
6. `validation` - Final quality checks

You can run whatever phases you want. They're just labels. But the system validates at checkpoints.