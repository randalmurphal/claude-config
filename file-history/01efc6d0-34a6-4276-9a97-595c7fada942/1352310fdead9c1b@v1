---
name: conduct
description: Orchestrate complex development tasks using MCP V2 - BUILD what the user requests with REAL validation
---

# /conduct - Orchestrated Development with MCP V2

**USE THIS FOR:** Complex multi-module tasks that need intelligent coordination with bulletproof validation.

## What V2 Changed

**V1 Issues:**
- Self-validation (finalize_phase asked "did tests pass?")
- No real checkpoints (couldn't recover from failures)
- No parallel work support
- Same workflow for 1-file and 100-file tasks
- 15 phantom tools documented but not implemented

**V2 Fixes:**
- **REAL validation** - Actually runs pytest/ruff/imports
- **Git checkpoints** - Rollback on failures
- **Parallel work** - Git worktrees with smart merging
- **Complexity scaling** - Adapts workflow to task size
- **Task decomposition** - Breaks massive tasks into subtasks
- **21 working tools** - All implemented and tested

## When to Use /conduct

✅ **DO use /conduct for:**
- Multi-module features (3+ files across different modules)
- System refactors (touching 10+ files)
- Architecture changes (affects multiple layers)
- Massive tasks (30+ files, 20+ hours)

❌ **DON'T use /conduct for:**
- Single file changes (just edit directly)
- Quick fixes (faster without orchestration overhead)
- Exploratory work (use spikes first)

## Real Workflow (V2)

### Small Task (1-3 files, <3h)
```
You: "/conduct Add logging to user service"

1. start_task → complexity="small"
2. skeleton phase → validate imports
3. implementation phase → VALIDATE (pytest/ruff/imports) → CHECKPOINT
4. complete_task
```

### Medium Task (4-10 files, 3-8h)
```
You: "/conduct Implement user authentication with JWT tokens"

1. start_task → complexity="medium"
2. architecture phase → design modules
3. skeleton phase → VALIDATE → CHECKPOINT
4. implementation phase → VALIDATE → CHECKPOINT
5. testing phase → VALIDATE
6. complete_task
```

### Large Task (10-30 files, 8-20h, parallel work)
```
You: "/conduct Refactor API layer across auth, cart, and payment modules"

1. start_task → complexity="large" → recommends parallel
2. architecture phase → identify 3 modules
3. create_worktree("auth"), create_worktree("cart"), create_worktree("payment")
4. skeleton phase (in parallel worktrees) → merge → VALIDATE → CHECKPOINT
5. implementation phase (in parallel) → merge → VALIDATE → CHECKPOINT
6. integration phase → VALIDATE
7. complete_task → cleanup worktrees
```

### Massive Task (30+ files, 20-100h, decomposed)
```
You: "/conduct Build complete e-commerce platform"

1. start_task → complexity="massive"
2. decompose_task → 5 subtasks:
   - Foundation (data models)
   - Authentication
   - Shopping cart
   - Payment processing
   - Admin dashboard
3. For each subtask:
   a. get_next_subtask
   b. Run LARGE workflow
   c. mark_subtask_complete → CHECKPOINT
4. Integration testing
5. complete_task
```

### With Validation Failure (blocks progression)
```
You: "/conduct Implement user registration"

1. start_task
2. skeleton phase → imports pass → CHECKPOINT
3. implementation phase
4. finalize_phase("implementation") → TESTS FAIL

System: "Cannot proceed to next phase. Validation failed:
- test_registration.py::test_email_validation FAILED
- Coverage: 87% (need 90%+)

Suggestion: Fix failing test and add tests for edge cases."

5. You fix tests
6. finalize_phase("implementation") → TESTS PASS → CHECKPOINT
7. Continue...
```

### With Rollback
```
You: "/conduct Refactor authentication system"

1. start_task
2. skeleton phase → CHECKPOINT (checkpoint_a)
3. implementation phase → CHECKPOINT (checkpoint_b)
4. testing phase → something breaks badly
5. list_checkpoints → see checkpoint_a and checkpoint_b
6. rollback_to_checkpoint(checkpoint_b) → restore to implementation
7. Fix implementation
8. Continue from implementation phase
```

## Available Tools (21 total, all working)

**Core Workflow (7):**
- start_task (with complexity detection)
- prepare_phase
- finalize_phase (with REAL validation)
- record_phase_result
- complete_task
- get_task_status
- parse_ready_specification

**Validation (1):**
- validate_phase (runs pytest/ruff/imports)

**Checkpoints (3):**
- create_checkpoint
- rollback_to_checkpoint
- list_checkpoints

**Worktrees (2):**
- create_worktree
- merge_worktrees

**Complexity (1):**
- analyze_task_complexity

**Decomposition (3):**
- decompose_task
- get_next_subtask
- mark_subtask_complete

**Intelligence (4):**
- analyze_project
- augment_ready_spec
- validate_ready_spec
- synthesize_learnings

## Success Criteria (How to know it's working)

✅ **Validation blocks progression** - Can't move forward with failing tests
✅ **Checkpoints auto-created** - After each validated phase
✅ **Rollback works** - Can recover from failures without losing all work
✅ **Parallel work isolated** - Modules don't conflict in worktrees
✅ **Complexity detected accurately** - Right workflow for task size
✅ **Progress preserved** - Redis state + git commits = full recovery

## Key V2 Features in Action

### 1. Real Validation (Biggest Change)

**V1 (broken):**
```
finalize_phase → "Did tests pass?" → you say "yes" → chaos
```

**V2 (bulletproof):**
```
finalize_phase → runs pytest → tests fail → progression BLOCKED
→ "Fix test_auth.py::test_login before proceeding"
→ you fix tests
→ finalize_phase → tests pass → CHECKPOINT created → proceed
```

### 2. Git Checkpoints (Automatic Snapshots)

**Automatic:**
```
skeleton phase complete → VALIDATE → CHECKPOINT (checkpoint_a)
implementation phase complete → VALIDATE → CHECKPOINT (checkpoint_b)
testing phase fails badly → rollback_to_checkpoint(checkpoint_b)
→ git reset --hard to checkpoint_b
→ Redis state cleared to checkpoint_b
→ continue from implementation
```

**Manual:**
```
# Create checkpoint manually
create_checkpoint(task_id, phase="custom", validation_passed=True)

# List all checkpoints
list_checkpoints(task_id) → shows all snapshots

# Rollback to any checkpoint
rollback_to_checkpoint(task_id, checkpoint_id)
```

### 3. Parallel Work with Worktrees

**For multi-module tasks:**
```
# Architecture identifies 3 modules
architecture_phase → ["auth", "cart", "payment"]

# Create isolated worktrees
create_worktree(task_id, module="auth") → worktree_auth/
create_worktree(task_id, module="cart") → worktree_cart/
create_worktree(task_id, module="payment") → worktree_payment/

# Agents work in parallel (no conflicts!)
skeleton_phase → all 3 agents work simultaneously

# Merge when done
merge_worktrees(task_id, modules=["auth", "cart", "payment"])
→ smart conflict resolution
→ validates after merge
→ CHECKPOINT created
```

### 4. Complexity Scaling (Right Workflow for Size)

**Auto-detection:**
```
"Add logging" → small → skeleton → implement → validate
"Implement auth" → medium → arch → skeleton → implement → test → validate
"Refactor API" → large → arch → skeleton → validate → implement → test → integrate
"Build platform" → massive → decompose into 5 subtasks
```

**Manual override:**
```
start_task(description="...", complexity="large")  # Force large workflow
```

### 5. Task Decomposition (Massive Tasks)

**Automatic breakdown:**
```
"Build e-commerce platform"
→ decompose_task
→ Returns 5 subtasks:
   1. Foundation (models, DB schema)
   2. Authentication (register, login, JWT)
   3. Product catalog (CRUD, search)
   4. Shopping cart (persistence, checkout)
   5. Admin dashboard (orders, users)

→ For each subtask:
   get_next_subtask → run full workflow → mark_subtask_complete

→ Integration testing
→ complete_task
```

## Migration from V1

If you have old V1 tasks:
- Remove references to phantom tools (many were documented but not implemented)
- Add complexity hints to description ("small change" vs "major refactor")
- Expect validation to actually run (tests must pass!)
- Use checkpoints for recovery (no more manual git operations)

## Tips for Best Results

1. **Write good descriptions** - "small change" vs "complete refactor" affects complexity detection
2. **Trust the validation** - If tests fail, fix them (don't bypass)
3. **Use checkpoints** - Don't be afraid to rollback and try again
4. **Let it decompose massive tasks** - Easier than doing all at once
5. **Review merge conflicts** - Smart strategy isn't perfect, check its work
6. **Check complexity recommendations** - Helps select right workflow

## Example Usage

```bash
# In your project directory (optionally with .prelude/READY.md)
/conduct "implement user authentication with JWT tokens"

# System analyzes complexity → "medium"
# Selects workflow: architecture → skeleton → implementation → testing
# Runs REAL validation at each checkpoint
# Blocks progression if tests fail
# Creates git checkpoints after validated phases
# Result: Bulletproof autonomous development
```

## Common Patterns

### Pattern: Fix Until It Works
```
finalize_phase("implementation") → tests fail
→ fix tests
→ finalize_phase("implementation") → tests fail again
→ fix more tests
→ finalize_phase("implementation") → tests pass → CHECKPOINT
→ proceed to next phase
```

### Pattern: Rollback and Retry
```
implementation complete → CHECKPOINT
testing complete → CHECKPOINT
integration breaks everything
→ list_checkpoints → see all checkpoints
→ rollback_to_checkpoint(testing_checkpoint)
→ fix implementation
→ finalize_phase("implementation") → CHECKPOINT
→ continue to testing
```

### Pattern: Parallel Module Work
```
architecture identifies N modules
→ create_worktree for each module
→ agents work in parallel (no conflicts)
→ merge_worktrees(all modules)
→ VALIDATE → CHECKPOINT
→ if merge validation fails:
   → fix conflicts
   → merge_worktrees again
   → VALIDATE → CHECKPOINT
```

### Pattern: Massive Task Decomposition
```
"Build complete system"
→ decompose_task → 5 subtasks
→ while get_next_subtask has work:
   → run full workflow for subtask
   → VALIDATE → CHECKPOINT
   → mark_subtask_complete
   → get_next_subtask
→ all subtasks complete
→ integration testing
→ complete_task
```

## Workflow Visualization

### Small Task Flow
```
start → skeleton → [validate] → implement → [validate+checkpoint] → done
```

### Medium Task Flow
```
start → arch → skeleton → [validate+checkpoint]
→ implement → [validate+checkpoint]
→ test → [validate] → done
```

### Large Task Flow (with parallel)
```
start → arch → [identify modules]
→ create_worktrees
→ skeleton (parallel) → merge → [validate+checkpoint]
→ implement (parallel) → merge → [validate+checkpoint]
→ integrate → [validate] → cleanup → done
```

### Massive Task Flow (with decomposition)
```
start → decompose → [5 subtasks]
→ subtask 1: [full large workflow] → [checkpoint]
→ subtask 2: [full large workflow] → [checkpoint]
→ subtask 3: [full large workflow] → [checkpoint]
→ subtask 4: [full large workflow] → [checkpoint]
→ subtask 5: [full large workflow] → [checkpoint]
→ integrate all → [validate] → done
```

## Error Recovery Patterns

### When Validation Fails
```
1. Read the validation error message
2. Fix the specific issue (failing test, linting error, import error)
3. Re-run finalize_phase until it passes
4. Validation blocks progression until fixed
```

### When Implementation Breaks
```
1. list_checkpoints → see all snapshots
2. rollback_to_checkpoint(last_good_checkpoint)
3. Fix implementation with better approach
4. finalize_phase → VALIDATE → new CHECKPOINT
5. Continue forward
```

### When Merge Conflicts Occur
```
1. merge_worktrees uses "smart" strategy (prefers simpler code)
2. Review conflicts in response
3. If conflicts unacceptable:
   → Fix conflicted files manually
   → validate_phase to ensure nothing broke
   → create_checkpoint to snapshot fix
4. Continue workflow
```

## What Makes V2 Bulletproof

1. **Real validation blocks bad code** - Can't proceed with failing tests
2. **Git checkpoints preserve progress** - Never lose hours of work
3. **Worktrees eliminate conflicts** - Parallel work without stepping on toes
4. **Complexity detection** - Right workflow for task size
5. **Decomposition handles massive tasks** - Break 100-file tasks into chunks
6. **All tools implemented** - No phantom features, everything works

## Quick Reference

**Start orchestration:**
```
/conduct "your task description"
```

**If validation fails:**
- Fix the issue
- Re-run finalize_phase
- System blocks until tests pass

**If things go wrong:**
- list_checkpoints
- rollback_to_checkpoint(checkpoint_id)
- Continue from checkpoint

**For massive tasks:**
- System decomposes automatically
- Work through subtasks sequentially
- Each subtask checkpointed

**For parallel work:**
- System creates worktrees automatically
- Merges with smart conflict resolution
- Validates after merge

---

**V2 Bottom Line:**
- REAL validation (no more self-validation lies)
- Git checkpoints (rollback on failures)
- Parallel worktrees (isolated module work)
- Complexity scaling (right workflow for size)
- Task decomposition (handle massive tasks)
- 21 working tools (all implemented, all tested)

**When you run /conduct, you get bulletproof autonomous development with validation that actually works.**