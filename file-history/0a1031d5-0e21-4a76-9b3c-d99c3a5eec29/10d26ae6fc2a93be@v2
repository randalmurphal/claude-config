"""
Context Warmer - Pre-warm Redis cache with task/file/component context.

Runs asynchronously in response to events:
- Task start (orchestration)
- Phase change (orchestration)
- File operations (PostToolUse hook)

Enables <10ms context injection by reading from cache instead of
performing expensive semantic retrieval in the hook.

NO DEFAULTS - fail loud on errors.
"""

import logging
import json
import time
from typing import List, Dict, Optional, Any
from pathlib import Path
import hashlib

from prism_mcp.storage.redis_cache import RedisCache
from prism_mcp.core.orchestrator import get_orchestrator
from prism_mcp.integrations.query_translator import QueryTranslator
from prism_mcp.storage.neo4j_manager import Neo4jManager

logger = logging.getLogger(__name__)


class ContextWarmer:
    """
    Pre-warm Redis cache with contextual information.

    Responsibilities:
    - Warm task context when orchestration starts
    - Warm component patterns when components enter focus
    - Update current file context on file operations
    - Track conversational state (last file, last topic)

    Cache keys:
    - context:{session_id}:task → Task metadata
    - context:{session_id}:current_file → Current file context
    - context:{session_id}:last_topic → Last discussed topic
    - patterns:{session_id}:{component}:{phase} → Pre-fetched patterns
    - dependencies:{session_id}:{component} → Component dependencies
    """

    def __init__(self):
        """Initialize context warmer."""
        self.redis = RedisCache()
        self.orchestrator = get_orchestrator()
        self.translator = QueryTranslator()
        self.neo4j = Neo4jManager()

        logger.info("ContextWarmer initialized")

    def warm_task_context(
        self,
        task_id: str,
        phase: str,
        complexity: str,
        components: List[str],
        session_id: str,
        project_id: Optional[str] = None
    ):
        """
        Warm cache when orchestration task starts.

        Caches:
        - Task metadata (id, phase, complexity)
        - Component list
        - Component-specific patterns for current phase

        Args:
            task_id: Task identifier
            phase: Current phase (prepare/skeleton/implementation/validation)
            complexity: Task complexity (small/medium/large/massive)
            components: List of component names
            session_id: Session ID
            project_id: Optional project ID

        Raises:
            RuntimeError: If required params missing
        """
        if not task_id:
            raise RuntimeError("task_id required")
        if not phase:
            raise RuntimeError("phase required")
        if not session_id:
            raise RuntimeError("session_id required")

        logger.info(f"Warming task context: {task_id} (phase={phase}, complexity={complexity})")

        # Cache task metadata
        task_context = {
            "task_id": task_id,
            "phase": phase,
            "complexity": complexity,
            "components": components[:5],  # Top 5 only
            "project_id": project_id,
            "timestamp": time.time()
        }

        self.redis.client.setex(
            f"context:{session_id}:task",
            3600,  # 1 hour TTL
            json.dumps(task_context)
        )

        # Pre-warm patterns for top 3 components
        for component in components[:3]:
            self._warm_component_patterns(
                component=component,
                phase=phase,
                session_id=session_id,
                project_id=project_id
            )

            # Warm component dependencies
            self._warm_component_dependencies(
                component=component,
                session_id=session_id,
                project_id=project_id
            )

        logger.info(f"Task context warmed: {task_id} with {len(components[:3])} components")

    def warm_file_context(
        self,
        file_path: str,
        symbol: Optional[str],
        line: Optional[int],
        component: Optional[str],
        session_id: str,
        operation: str = "read"
    ):
        """
        Warm cache when file is accessed.

        Called by PostToolUse hook after Read/Edit/Write operations.

        Caches:
        - Current file path
        - Current symbol (function/class)
        - Current line number
        - Component name (if known)

        Args:
            file_path: File path (absolute or relative)
            symbol: Current symbol (function/class name)
            line: Current line number
            component: Component name (extracted from file path or known)
            session_id: Session ID
            operation: Tool operation (read/edit/write)

        Raises:
            RuntimeError: If required params missing
        """
        if not file_path:
            raise RuntimeError("file_path required")
        if not session_id:
            raise RuntimeError("session_id required")

        logger.debug(f"Warming file context: {file_path} (operation={operation})")

        # Extract component from file path if not provided
        if not component:
            component = self._extract_component_from_path(file_path)

        file_context = {
            "file_path": file_path,
            "symbol": symbol,
            "line": line,
            "component": component,
            "operation": operation,
            "timestamp": time.time()
        }

        self.redis.client.setex(
            f"context:{session_id}:current_file",
            600,  # 10 minute TTL (short - context goes stale)
            json.dumps(file_context)
        )

        # Update last topic (for conversational state)
        if symbol:
            topic = f"{component}.{symbol}" if component else symbol
        else:
            topic = Path(file_path).stem  # File name without extension

        self.redis.client.setex(
            f"context:{session_id}:last_topic",
            300,  # 5 minute TTL
            topic
        )

        logger.debug(f"File context warmed: {file_path} (component={component})")

    def update_phase(
        self,
        phase: str,
        session_id: str
    ):
        """
        Update cached phase when orchestration changes phase.

        Re-warms component patterns for new phase.

        Args:
            phase: New phase name
            session_id: Session ID

        Raises:
            RuntimeError: If params missing or no task context
        """
        if not phase:
            raise RuntimeError("phase required")
        if not session_id:
            raise RuntimeError("session_id required")

        logger.info(f"Updating phase to: {phase}")

        # Get current task context
        task_json = self.redis.client.get(f"context:{session_id}:task")
        if not task_json:
            logger.warning("No task context found, cannot update phase")
            return

        task_context = json.loads(task_json)
        task_context["phase"] = phase
        task_context["timestamp"] = time.time()

        # Update task context
        self.redis.client.setex(
            f"context:{session_id}:task",
            3600,
            json.dumps(task_context)
        )

        # Re-warm patterns for new phase
        components = task_context.get("components", [])
        project_id = task_context.get("project_id")

        for component in components[:3]:
            self._warm_component_patterns(
                component=component,
                phase=phase,
                session_id=session_id,
                project_id=project_id
            )

        logger.info(f"Phase updated to {phase}, patterns re-warmed")

    def _warm_component_patterns(
        self,
        component: str,
        phase: str,
        session_id: str,
        project_id: Optional[str] = None
    ):
        """
        Pre-fetch patterns for component based on phase.

        Phase-specific queries:
        - prepare: ADRs and architectural decisions
        - skeleton: Interface patterns and signatures
        - implementation: Gotchas, security patterns, best practices
        - validation: Test patterns

        Args:
            component: Component name
            phase: Current phase
            session_id: Session ID
            project_id: Optional project ID
        """
        # Build phase-specific query
        if phase == "prepare":
            query = f"architectural decisions for {component}"
            memory_types = ["architecture_decision", "research_note"]
        elif phase == "skeleton":
            query = f"interface patterns for {component}"
            memory_types = ["code_pattern"]
        elif phase == "implementation":
            query = f"gotchas and security patterns for {component}"
            memory_types = ["correction", "code_pattern"]
        elif phase == "validation":
            query = f"test patterns for {component}"
            memory_types = ["code_pattern"]
        else:
            logger.warning(f"Unknown phase: {phase}, using default query")
            query = f"patterns for {component}"
            memory_types = ["code_pattern"]

        try:
            # Use PRISM intelligent retrieval
            patterns = self.orchestrator.retrieve_intelligent(
                query=query,
                session_id=session_id,
                retrieval_mode="fast",  # 500ms budget
                memory_types=memory_types,
                limit=3,
                project_id=project_id
            )

            # Extract pattern content
            pattern_list = []
            for pattern in patterns:
                pattern_list.append({
                    "content": pattern.content[:200],  # Truncate long patterns
                    "memory_type": pattern.memory_type,
                    "tier": pattern.tier
                })

            # Cache patterns
            self.redis.client.setex(
                f"patterns:{session_id}:{component}:{phase}",
                1800,  # 30 minute TTL
                json.dumps(pattern_list)
            )

            logger.debug(f"Warmed {len(pattern_list)} patterns for {component} ({phase})")

        except Exception as e:
            logger.error(f"Error warming patterns for {component}: {e}")

    def _warm_component_dependencies(
        self,
        component: str,
        session_id: str,
        project_id: Optional[str] = None
    ):
        """
        Pre-fetch component dependencies from Neo4j.

        Finds other components this component depends on.

        Args:
            component: Component name
            session_id: Session ID
            project_id: Optional project ID
        """
        try:
            # Query Neo4j for dependencies
            query = """
            MATCH (c:Component {name: $component})
            OPTIONAL MATCH (c)-[:DEPENDS_ON]->(dep:Component)
            RETURN collect(dep.name) as dependencies
            """

            if project_id:
                query = """
                MATCH (c:Component {name: $component, project_id: $project_id})
                OPTIONAL MATCH (c)-[:DEPENDS_ON]->(dep:Component)
                RETURN collect(dep.name) as dependencies
                """

            params = {"component": component}
            if project_id:
                params["project_id"] = project_id

            results = self.neo4j.query(query, **params)

            if results:
                dependencies = results[0].get("dependencies", [])

                # Cache dependencies
                self.redis.client.setex(
                    f"dependencies:{session_id}:{component}",
                    3600,  # 1 hour TTL
                    json.dumps(dependencies)
                )

                logger.debug(f"Warmed {len(dependencies)} dependencies for {component}")

        except Exception as e:
            logger.error(f"Error warming dependencies for {component}: {e}")

    def _extract_component_from_path(self, file_path: str) -> Optional[str]:
        """
        Extract component name from file path.

        Examples:
        - src/auth/validator.py → auth_validator
        - prism_mcp/core/memory_engine.py → memory_engine
        - services/user_service.py → user_service

        Args:
            file_path: File path (absolute or relative)

        Returns:
            Component name or None
        """
        path = Path(file_path)

        # Get file stem (without extension)
        file_stem = path.stem

        # Get parent directory name
        parent = path.parent.name if path.parent else ""

        # Combine if parent looks like a module
        if parent and parent not in ["src", "lib", "app", "services", "core", "utils"]:
            component = f"{parent}_{file_stem}"
        else:
            component = file_stem

        return component

    def clear_session_context(self, session_id: str):
        """
        Clear all cached context for a session.

        Args:
            session_id: Session ID to clear

        Raises:
            RuntimeError: If session_id missing
        """
        if not session_id:
            raise RuntimeError("session_id required")

        logger.info(f"Clearing context for session: {session_id}")

        # Find all keys for this session
        pattern = f"*:{session_id}:*"
        cursor = 0
        deleted = 0

        while True:
            cursor, keys = self.redis.client.scan(cursor, match=pattern, count=100)
            if keys:
                self.redis.client.delete(*keys)
                deleted += len(keys)
            if cursor == 0:
                break

        logger.info(f"Cleared {deleted} cache entries for session {session_id}")


def get_context_warmer() -> ContextWarmer:
    """
    Get singleton context warmer instance.

    Returns:
        ContextWarmer instance
    """
    return ContextWarmer()