#!/usr/bin/env python3
"""
Intelligent Forex Trader Codebase Indexer
Extracts code patterns and architectural knowledge for PRISM MCP
"""
import ast
import os
import requests
from pathlib import Path
from typing import List, Dict, Any
import json

API_URL = "http://localhost:8090"
API_KEY = "prism_development_key_2024"
FOREX_ROOT = "/home/randy/repos/forex_trader"

# Directories to skip
SKIP_DIRS = {
    'node_modules', '.git', 'data', '__pycache__', '.venv',
    'venv', 'build', 'dist', '.pytest_cache', 'logs'
}

# File extensions to index
CODE_EXTENSIONS = {'.py', '.go'}

class CodeIndexer:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Bearer {API_KEY}",
            "Content-Type": "application/json"
        })
        self.indexed_count = 0
        self.error_count = 0

    def store_memory(self, content: str, memory_type: str, context: Dict[str, Any], tags: List[str]):
        """Store a memory via PRISM API"""
        payload = {
            "content": content,
            "memory_type": memory_type,
            "context": {
                "session_id": "forex_trader_indexing",
                "role": "assistant",
                "task": "indexing forex_trader codebase",
                "project_id": "forex_trader",
                **context
            },
            "tags": tags
        }

        try:
            response = self.session.post(f"{API_URL}/api/store_memory", json=payload)
            if response.status_code == 200:
                result = response.json()
                self.indexed_count += 1
                return result.get('memory_id')
            else:
                self.error_count += 1
                print(f"  âœ— Failed: {response.status_code} - {response.text[:100]}")
                return None
        except Exception as e:
            self.error_count += 1
            print(f"  âœ— Error: {e}")
            return None

    def extract_python_symbols(self, file_path: Path, content: str):
        """Extract classes and functions from Python file"""
        try:
            tree = ast.parse(content)
            rel_path = file_path.relative_to(FOREX_ROOT)

            for node in ast.walk(tree):
                # Extract classes
                if isinstance(node, ast.ClassDef):
                    class_code = ast.get_source_segment(content, node)
                    if class_code and len(class_code) < 5000:  # Limit size
                        docstring = ast.get_docstring(node) or "No description"

                        # Store code pattern
                        memory_id = self.store_memory(
                            content=class_code[:2000],  # First 2000 chars
                            memory_type="code_pattern",
                            context={
                                "file_path": str(rel_path),
                                "symbol_name": node.name,
                                "symbol_type": "class",
                                "language": "python"
                            },
                            tags=["python", "class", "forex_trader", rel_path.parts[0]]
                        )

                        if memory_id:
                            # Store semantic note about the class
                            semantic_note = f"Class `{node.name}` in {rel_path}: {docstring[:200]}"
                            self.store_memory(
                                content=semantic_note,
                                memory_type="research_note",
                                context={
                                    "file_path": str(rel_path),
                                    "symbol_name": node.name,
                                    "related_code_id": memory_id
                                },
                                tags=["architecture", "forex_trader", rel_path.parts[0]]
                            )
                            print(f"  âœ“ Indexed class: {node.name}")

                # Extract important functions (public functions or those with docstrings)
                elif isinstance(node, ast.FunctionDef):
                    if not node.name.startswith('_') or ast.get_docstring(node):
                        func_code = ast.get_source_segment(content, node)
                        if func_code and len(func_code) < 3000:
                            docstring = ast.get_docstring(node) or "No description"

                            memory_id = self.store_memory(
                                content=func_code[:1500],
                                memory_type="code_pattern",
                                context={
                                    "file_path": str(rel_path),
                                    "symbol_name": node.name,
                                    "symbol_type": "function",
                                    "language": "python"
                                },
                                tags=["python", "function", "forex_trader", rel_path.parts[0]]
                            )

                            if memory_id:
                                print(f"  âœ“ Indexed function: {node.name}")

        except SyntaxError as e:
            print(f"  âš  Syntax error in {file_path}: {e}")
        except Exception as e:
            print(f"  âš  Error parsing {file_path}: {e}")

    def extract_module_summary(self, file_path: Path, content: str):
        """Extract module-level documentation"""
        try:
            tree = ast.parse(content)
            docstring = ast.get_docstring(tree)

            if docstring and len(docstring) > 50:
                rel_path = file_path.relative_to(FOREX_ROOT)

                self.store_memory(
                    content=f"Module {rel_path}: {docstring}",
                    memory_type="research_note",
                    context={
                        "file_path": str(rel_path),
                        "module_name": file_path.stem
                    },
                    tags=["documentation", "forex_trader", "module", rel_path.parts[0]]
                )
                print(f"  âœ“ Indexed module doc: {file_path.name}")
        except:
            pass

    def index_directory(self, root_dir: Path):
        """Recursively index all code files"""
        python_files = []

        for root, dirs, files in os.walk(root_dir):
            # Skip unwanted directories
            dirs[:] = [d for d in dirs if d not in SKIP_DIRS]

            root_path = Path(root)
            for file in files:
                if file.endswith('.py'):
                    python_files.append(root_path / file)

        print(f"\nðŸ“‚ Found {len(python_files)} Python files to index\n")

        for i, file_path in enumerate(python_files, 1):
            print(f"[{i}/{len(python_files)}] {file_path.relative_to(FOREX_ROOT)}")

            try:
                content = file_path.read_text(encoding='utf-8')

                # Extract module summary
                self.extract_module_summary(file_path, content)

                # Extract symbols
                self.extract_python_symbols(file_path, content)

            except Exception as e:
                print(f"  âœ— Failed to read: {e}")

        print(f"\n{'='*60}")
        print(f"âœ… Indexing complete!")
        print(f"   Indexed: {self.indexed_count} memories")
        print(f"   Errors: {self.error_count}")
        print(f"{'='*60}\n")

def main():
    print("="*60)
    print("ðŸš€ Forex Trader Intelligent Indexer")
    print("="*60)

    indexer = CodeIndexer()
    indexer.index_directory(Path(FOREX_ROOT))

    print("\nðŸ’¡ Now try queries like:")
    print('  - "How does risk management work?"')
    print('  - "Show me the trading simulation logic"')
    print('  - "What data models exist for trades?"')
    print('  - "How is backtesting implemented?"')
    print("\nUse: python3 /tmp/forex_query.py")

if __name__ == "__main__":
    main()