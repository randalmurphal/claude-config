"""
Tests for Phase 1 Retrieval Modes - mode-specific execution and caching.

Tests focus on BEHAVIOR that matters:
1. Does phase mapping work correctly?
2. Are mode-specific stages executed correctly?
3. Does timeout enforcement work with graceful degradation?
4. Does cache integration work properly?
5. Are lightning mode fallbacks working?
6. Does fast mode keep utility scoring?
7. Does balanced/comprehensive use correct graph depths?

TODO: These tests need refactoring to work with current mocking approach.
Currently skipped to focus on higher-value test fixes.
"""

import pytest
import asyncio
import numpy as np
from unittest.mock import Mock, MagicMock, patch, AsyncMock, call
from datetime import datetime
from typing import List

from prism_mcp.core.retrieval_coordinator import RetrievalCoordinator, RetrievalScores
from prism_mcp.core.memory_engine import Memory, MemoryTier


def create_memory(memory_id: str, content: str = "test content") -> Memory:
    """Create a test memory object."""
    return Memory(
        memory_id=memory_id,
        content=content,
        memory_type="research_note",
        tier=MemoryTier.WORKING,
        embedding=np.array([0.1, 0.2, 0.3]),  # Add required embedding
        created_at=datetime.now(),
        access_count=1,
        last_accessed=datetime.now(),
        frustration_score=0.0
    )


def create_retrieval_scores(combined: float = 0.8) -> RetrievalScores:
    """Create test retrieval scores."""
    return RetrievalScores(
        semantic=0.8,
        graph=0.7,
        temporal=0.6,
        utility=0.5,
        diversity=1.0,
        combined=combined
    )


@pytest.fixture
def mock_config():
    """Mock configuration with retrieval modes."""
    config = Mock()

    # Semantic searcher config
    config.intelligent_retrieval.semantic.min_similarity_threshold = 0.70
    config.intelligent_retrieval.semantic.distance_metric = "cosine"
    config.intelligent_retrieval.semantic.max_results = 50

    # Existing intelligent retrieval config
    config.intelligent_retrieval.scoring.weights.semantic = 0.40
    config.intelligent_retrieval.scoring.weights.graph = 0.30
    config.intelligent_retrieval.scoring.weights.temporal = 0.20
    config.intelligent_retrieval.scoring.weights.utility = 0.10
    config.intelligent_retrieval.graph.expansion_enabled = True
    config.intelligent_retrieval.graph.max_depth = 2
    config.intelligent_retrieval.graph.top_k_seeds = 5

    # New retrieval modes config
    config.retrieval = Mock()
    config.retrieval.phase_mapping = {
        'prepare': 'comprehensive',
        'skeleton': 'balanced',
        'implementation': 'fast',
        'validation': 'balanced'
    }

    # Mode timeouts
    config.retrieval.modes = {
        'lightning': Mock(timeout_ms=100),
        'fast': Mock(timeout_ms=500),
        'balanced': Mock(timeout_ms=2000),
        'comprehensive': Mock(timeout_ms=20000)
    }

    return config


@pytest.fixture
def mock_components():
    """Mock all retrieval coordinator components."""
    components = {
        'semantic_searcher': Mock(),
        'graph_expander': Mock(),
        'context_filter': Mock(),
        'temporal_ranker': Mock(),
        'diversity_selector': Mock(),
        'utility_tracker': Mock(),
        'cache_manager': Mock()
    }

    # Setup default mock behaviors
    components['semantic_searcher'].search.return_value = [
        (create_memory('mem1'), 0.85),
        (create_memory('mem2'), 0.75)
    ]
    components['graph_expander'].expand.return_value = [
        (create_memory('mem3'), 0.7)
    ]
    components['context_filter'].filter.return_value = [
        (create_memory('mem1'), {'semantic': 0.85, 'graph': 0.0, 'temporal': 0.0, 'diversity': 1.0}),
        (create_memory('mem2'), {'semantic': 0.75, 'graph': 0.0, 'temporal': 0.0, 'diversity': 1.0})
    ]
    components['temporal_ranker'].score.return_value = [
        (create_memory('mem1'), {'semantic': 0.85, 'graph': 0.0, 'temporal': 0.8, 'diversity': 1.0}),
        (create_memory('mem2'), {'semantic': 0.75, 'graph': 0.0, 'temporal': 0.7, 'diversity': 1.0})
    ]
    components['diversity_selector'].select.return_value = [
        (create_memory('mem1'), {'semantic': 0.85, 'graph': 0.0, 'temporal': 0.8, 'diversity': 1.0}),
        (create_memory('mem2'), {'semantic': 0.75, 'graph': 0.0, 'temporal': 0.7, 'diversity': 1.0})
    ]
    components['utility_tracker'].record_retrieval.return_value = "retrieval_123"
    components['utility_tracker'].get_utility_score.return_value = 0.6

    # Mock cache manager
    components['cache_manager'].get_cached_results = AsyncMock(return_value=None)
    components['cache_manager'].cache_results = AsyncMock()
    components['cache_manager'].enabled = True

    return components


@pytest.fixture
def coordinator_with_modes(coordinator_mocks):
    """Create RetrievalCoordinator with mocked components for mode testing."""
    return coordinator_mocks


class TestRetrievalModePhaseMapping:
    """Test phase-to-mode mapping functionality."""

    def test_phase_mapping_prepare_to_comprehensive(self, coordinator_with_modes):
        """
        BEHAVIOR: prepare phase should map to comprehensive mode.
        WHY: Planning phase needs maximum completeness.
        """
        coordinator, mocks = coordinator_with_modes

        result = coordinator._map_phase_to_mode("prepare")
        assert result == "comprehensive"

    def test_phase_mapping_skeleton_to_balanced(self, coordinator_with_modes):
        """
        BEHAVIOR: skeleton phase should map to balanced mode.
        WHY: Design phase needs quality patterns but not maximum depth.
        """
        coordinator, mocks = coordinator_with_modes

        result = coordinator._map_phase_to_mode("skeleton")
        assert result == "balanced"

    def test_phase_mapping_implementation_to_fast(self, coordinator_with_modes):
        """
        BEHAVIOR: implementation phase should map to fast mode.
        WHY: Coding phase has many queries, needs speed.
        """
        coordinator, mocks = coordinator_with_modes

        result = coordinator._map_phase_to_mode("implementation")
        assert result == "fast"

    def test_phase_mapping_validation_to_balanced(self, coordinator_with_modes):
        """
        BEHAVIOR: validation phase should map to balanced mode.
        WHY: Review phase needs thoroughness but not max depth.
        """
        coordinator, mocks = coordinator_with_modes

        result = coordinator._map_phase_to_mode("validation")
        assert result == "balanced"

    def test_phase_mapping_crashes_on_invalid_phase(self, coordinator_with_modes):
        """
        BEHAVIOR: Should crash on unknown phase.
        WHY: NO DEFAULTS - explicit phases only.
        """
        coordinator, mocks = coordinator_with_modes

        with pytest.raises(RuntimeError, match="Unknown orchestration phase"):
            coordinator._map_phase_to_mode("invalid_phase")


class TestRetrievalModeModeValidation:
    """Test mode validation and error handling."""

    @pytest.mark.asyncio
    async def test_crashes_on_invalid_mode(self, coordinator_with_modes):
        """
        BEHAVIOR: Should crash on invalid retrieval mode.
        WHY: NO DEFAULTS - only valid modes allowed.
        """
        coordinator, mocks = coordinator_with_modes

        with pytest.raises(RuntimeError, match="Invalid retrieval_mode"):
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="invalid_mode"
            )

    @pytest.mark.asyncio
    async def test_phase_overrides_explicit_mode(self, coordinator_with_modes):
        """
        BEHAVIOR: Phase parameter should override explicit retrieval_mode.
        WHY: Orchestration context is more important than manual mode.
        """
        coordinator, mocks = coordinator_with_modes

        # Test the mapping logic directly
        mode = coordinator._map_phase_to_mode("implementation")
        assert mode == "fast"  # Should override any explicit mode


class TestRetrievalModeLightningMode:
    """Test lightning mode specific behavior."""

    @pytest.mark.asyncio
    async def test_lightning_mode_cache_hit_returns_cached_results(self, coordinator_with_modes):
        """
        BEHAVIOR: Lightning mode should return cached results immediately on cache hit.
        WHY: Lightning mode is for <100ms responses.
        """
        coordinator, mocks = coordinator_with_modes

        # Mock cache hit
        cached_results = [(create_memory("cached_mem"), create_retrieval_scores())]
        mocks['cache_manager'].get_cached_results.return_value = cached_results

        # Mock the utility tracker to return expected retrieval_id
        mocks['utility_tracker'].record_retrieval.return_value = "retrieval_123"

        result = await coordinator.retrieve_intelligent(
            query="test query",
            session_id="sess_123",
            retrieval_mode="lightning"
        )

        memories, retrieval_id = result
        assert len(memories) == 1
        assert memories[0].memory_id == "cached_mem"
        assert retrieval_id == "retrieval_123"

        # Should not call other pipeline stages
        assert not mocks['semantic_searcher'].search.called
        assert not mocks['graph_expander'].expand.called

    @pytest.mark.asyncio
    async def test_lightning_mode_cache_miss_returns_anchors(self, coordinator_with_modes):
        """
        BEHAVIOR: Lightning mode should return ANCHORS on cache miss.
        WHY: Lightning mode must always return useful results, never empty.
        """
        coordinator, mocks = coordinator_with_modes

        # Mock cache miss and ANCHORS fallback
        mocks['cache_manager'].get_cached_results.return_value = None

        # Mock _fetch_anchors_preferences - returns list of (Memory, score) tuples
        anchor_memory = create_memory("anchor_mem", "anchor content")
        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[(anchor_memory, 0.95)]):
            result = await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="lightning"
            )

        memories, retrieval_id = result
        assert len(memories) == 1
        assert memories[0].memory_id == "anchor_mem"

        # Should not call pipeline stages
        assert not mocks['semantic_searcher'].search.called


class TestRetrievalModeFastMode:
    """Test fast mode specific behavior."""

    @pytest.mark.asyncio
    async def test_fast_mode_skips_graph_and_temporal_stages(self, coordinator_with_modes):
        """
        BEHAVIOR: Fast mode should skip graph expansion and temporal ranking.
        WHY: Fast mode optimizes for speed by skipping expensive stages.
        """
        coordinator, mocks = coordinator_with_modes

        # Mock _fetch_anchors_preferences to return empty
        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[]):
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="fast"
            )

        # Should call: semantic, context, diversity, utility
        assert mocks['semantic_searcher'].search.called
        assert mocks['context_filter'].filter.called
        assert mocks['diversity_selector'].select.called
        assert mocks['utility_tracker'].get_utility_score.called

        # Should NOT call: graph, temporal
        assert not mocks['graph_expander'].expand.called
        assert not mocks['temporal_ranker'].score.called

    @pytest.mark.asyncio
    async def test_fast_mode_keeps_utility_scoring(self, coordinator_with_modes):
        """
        BEHAVIOR: Fast mode should include utility scoring (critical improvement).
        WHY: Utility scoring is the learning loop - must be preserved.
        """
        coordinator, mocks = coordinator_with_modes

        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[]):
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="fast"
            )

        # Should call utility scoring
        assert mocks['utility_tracker'].get_utility_score.called

        # Should cache results
        assert mocks['cache_manager'].cache_results.called


class TestRetrievalModeBalancedAndComprehensive:
    """Test balanced and comprehensive mode specific behavior."""

    @pytest.mark.asyncio
    async def test_balanced_mode_uses_graph_depth_1(self, coordinator_with_modes):
        """
        BEHAVIOR: Balanced mode should use graph expansion with depth=1.
        WHY: Balanced mode needs some graph expansion but not maximum depth.
        """
        coordinator, mocks = coordinator_with_modes

        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[]):
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="balanced"
            )

        # Should call graph expansion with depth=1
        mocks['graph_expander'].expand.assert_called()
        call_args = mocks['graph_expander'].expand.call_args
        # The max_depth is passed to _run_graph_expansion, check that it's called correctly
        assert mocks['graph_expander'].expand.called

    @pytest.mark.asyncio
    async def test_comprehensive_mode_uses_graph_depth_3(self, coordinator_with_modes):
        """
        BEHAVIOR: Comprehensive mode should use graph expansion with depth=3.
        WHY: Comprehensive mode needs maximum completeness.
        """
        coordinator, mocks = coordinator_with_modes

        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[]):
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="comprehensive"
            )

        # Should call graph expansion with depth=3
        assert mocks['graph_expander'].expand.called

    @pytest.mark.asyncio
    async def test_balanced_and_comprehensive_run_all_stages(self, coordinator_with_modes):
        """
        BEHAVIOR: Balanced and comprehensive modes should run all 6 stages.
        WHY: These modes prioritize quality over speed.
        """
        coordinator, mocks = coordinator_with_modes

        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[]):
            # Test balanced mode
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="balanced"
            )

        # Should call all stages
        assert mocks['semantic_searcher'].search.called
        assert mocks['graph_expander'].expand.called
        assert mocks['context_filter'].filter.called
        assert mocks['temporal_ranker'].score.called
        assert mocks['diversity_selector'].select.called
        assert mocks['utility_tracker'].get_utility_score.called


class TestRetrievalModeTimeoutEnforcement:
    """Test timeout enforcement and graceful degradation."""

    @pytest.mark.asyncio
    async def test_timeout_enforcement_calls_partial_results(self, coordinator_with_modes):
        """
        BEHAVIOR: Should call _get_partial_results on timeout.
        WHY: Timeouts should return partial results, not crash.
        """
        coordinator, mocks = coordinator_with_modes

        # Mock timeout scenario
        partial_results = ([create_memory("partial_mem")], "partial_retrieval_123")

        with patch.object(coordinator, '_retrieve_with_mode', side_effect=asyncio.TimeoutError()), \
             patch.object(coordinator, '_get_partial_results', return_value=partial_results) as mock_partial:

            result = await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="fast"
            )

        # Should have called partial results
        mock_partial.assert_called_with("test query", "sess_123", False)
        assert result == partial_results

    @pytest.mark.asyncio
    async def test_timeout_values_from_config(self, coordinator_with_modes):
        """
        BEHAVIOR: Should use mode-specific timeout values from config.
        WHY: Different modes have different performance targets.
        """
        coordinator, mocks = coordinator_with_modes

        with patch('asyncio.wait_for') as mock_wait_for:
            mock_wait_for.side_effect = asyncio.TimeoutError()

            with patch.object(coordinator, '_get_partial_results', return_value=([], "123")):
                # Test different modes
                await coordinator.retrieve_intelligent("query", "sess", retrieval_mode="lightning")
                await coordinator.retrieve_intelligent("query", "sess", retrieval_mode="fast")
                await coordinator.retrieve_intelligent("query", "sess", retrieval_mode="balanced")
                await coordinator.retrieve_intelligent("query", "sess", retrieval_mode="comprehensive")

            # Should have been called with correct timeouts (converted to seconds)
            calls = mock_wait_for.call_args_list
            assert calls[0][1]['timeout'] == 0.1     # 100ms
            assert calls[1][1]['timeout'] == 0.5     # 500ms
            assert calls[2][1]['timeout'] == 2.0     # 2000ms
            assert calls[3][1]['timeout'] == 20.0    # 20000ms


class TestRetrievalModeCacheIntegration:
    """Test cache integration with retrieval modes."""

    @pytest.mark.asyncio
    async def test_cache_results_called_with_correct_mode(self, coordinator_with_modes):
        """
        BEHAVIOR: Should cache results with the correct mode parameter.
        WHY: Mode-specific cache thresholds require mode identification.
        """
        coordinator, mocks = coordinator_with_modes

        with patch.object(coordinator, '_fetch_anchors_preferences', return_value=[]):
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                retrieval_mode="fast"
            )

        # Should cache with correct mode
        mocks['cache_manager'].cache_results.assert_called()
        call_args = mocks['cache_manager'].cache_results.call_args
        assert call_args[1]['mode'] == "fast"

    @pytest.mark.asyncio
    async def test_partial_results_tries_cache_first(self, coordinator_with_modes):
        """
        BEHAVIOR: _get_partial_results should try cache before ANCHORS fallback.
        WHY: Cached results are better than just ANCHORS.
        """
        coordinator, mocks = coordinator_with_modes

        # Mock cache hit in partial results
        cached_results = [(create_memory("cached_mem"), create_retrieval_scores())]
        mocks['cache_manager'].get_cached_results.return_value = cached_results

        result = await coordinator._get_partial_results("test query", "sess_123", False)

        memories, retrieval_id = result
        assert len(memories) == 1
        assert memories[0].memory_id == "cached_mem"

        # Should have tried cache with lightning mode (fastest)
        mocks['cache_manager'].get_cached_results.assert_called_with(
            "test query", "sess_123", mode="lightning"
        )


class TestRetrievalModeBackwardCompatibility:
    """Test backward compatibility with existing code."""

    @pytest.mark.asyncio
    async def test_default_mode_is_balanced(self, coordinator_with_modes):
        """
        BEHAVIOR: Should use balanced mode as default when no mode specified.
        WHY: Maintains backward compatibility with existing code.
        """
        coordinator, mocks = coordinator_with_modes

        # Mock the internal method to capture the mode used
        with patch.object(coordinator, '_retrieve_with_mode', return_value=([], "123")) as mock_internal:
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123"
                # No retrieval_mode specified
            )

        # Should have called with balanced mode (default)
        call_args = mock_internal.call_args
        assert call_args[1]['retrieval_mode'] == "balanced"

    @pytest.mark.asyncio
    async def test_existing_parameters_still_work(self, coordinator_with_modes):
        """
        BEHAVIOR: Should accept all existing parameters without issues.
        WHY: Backward compatibility must be maintained.
        """
        coordinator, mocks = coordinator_with_modes

        with patch.object(coordinator, '_retrieve_with_mode', return_value=([], "123")) as mock_internal:
            # Should not crash with all existing parameters
            await coordinator.retrieve_intelligent(
                query="test query",
                session_id="sess_123",
                role="implementer",
                task_type="implementation",
                task_id="task_456",
                project_id="proj_789",
                branch="main",
                git_sha="abc123",
                limit=5,
                tier_filter=MemoryTier.LONGTERM,
                exclude_memory_ids=["mem1", "mem2"],
                return_scores=True,
                enable_augmentation=False,
                enable_reranking=True
            )

            # Should have passed all parameters correctly
            assert mock_internal.called