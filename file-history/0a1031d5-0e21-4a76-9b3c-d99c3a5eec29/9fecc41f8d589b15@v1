#!/bin/bash

# PRISM GPU Startup Script - Complete system initialization
# Uses host networking for maximum portability across systems

set -e  # Exit on error

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"

echo "===================================================="
echo "PRISM GPU Startup Script (Host Networking Mode)"
echo "===================================================="

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored messages
print_status() { echo -e "${GREEN}[✓]${NC} $1"; }
print_error() { echo -e "${RED}[✗]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[!]${NC} $1"; }

# Check GPU availability
check_gpu() {
    echo "Checking GPU availability..."
    if nvidia-smi &>/dev/null; then
        print_status "GPU detected:"
        nvidia-smi --query-gpu=name,memory.total --format=csv,noheader || true
    else
        print_error "No GPU detected. This script requires GPU support."
        exit 1
    fi
}

# Stop all existing containers
cleanup_containers() {
    echo ""
    echo "Cleaning up existing containers..."

    # Stop and remove PRISM containers
    for container in prism-api prism-neo4j prism-qdrant prism-redis; do
        if nerdctl ps -a | grep -q "$container"; then
            print_warning "Stopping $container..."
            nerdctl stop "$container" 2>/dev/null || true
            nerdctl rm "$container" 2>/dev/null || true
        fi
    done

    print_status "Cleanup complete"
}

# Start database containers using host networking
start_databases() {
    echo ""
    echo "Starting database containers (host networking)..."

    # Start Neo4j
    print_status "Starting Neo4j..."
    nerdctl run -d \
        --name prism-neo4j \
        --network host \
        -v prism-neo4j-data:/data \
        -e NEO4J_AUTH=neo4j/prism_neo4j_2024 \
        -e NEO4J_PLUGINS='["graph-data-science"]' \
        -e NEO4J_dbms_memory_heap_max__size=4G \
        -e NEO4J_server_http_listen__address=:7474 \
        -e NEO4J_server_bolt_listen__address=:7687 \
        neo4j:5.13-community

    # Start Qdrant
    print_status "Starting Qdrant..."
    nerdctl run -d \
        --name prism-qdrant \
        --network host \
        -v prism-qdrant-storage:/qdrant/storage \
        -e QDRANT__SERVICE__HTTP_PORT=6333 \
        -e QDRANT__SERVICE__GRPC_PORT=6334 \
        qdrant/qdrant:v1.7.4

    # Start Redis
    print_status "Starting Redis..."
    nerdctl run -d \
        --name prism-redis \
        --network host \
        -v prism-redis-data:/data \
        redis:7-alpine \
        redis-server --port 6379

    print_status "All databases started"
}

# Wait for databases to be ready
wait_for_databases() {
    echo ""
    echo "Waiting for databases to be ready..."

    # Wait for Neo4j
    echo -n "  Neo4j: "
    for i in {1..30}; do
        if curl -s http://localhost:7474 >/dev/null 2>&1; then
            print_status "ready"
            break
        fi
        echo -n "."
        sleep 2
    done

    # Wait for Qdrant (root endpoint, not /health)
    echo -n "  Qdrant: "
    for i in {1..30}; do
        if curl -s http://localhost:6333/ | grep -q "qdrant" 2>/dev/null; then
            print_status "ready"
            break
        fi
        echo -n "."
        sleep 2
    done

    # Wait for Redis
    echo -n "  Redis: "
    for i in {1..30}; do
        if nerdctl exec prism-redis redis-cli ping 2>/dev/null | grep -q PONG; then
            print_status "ready"
            break
        fi
        echo -n "."
        sleep 2
    done
}

# Check if Docker image exists
check_docker_image() {
    echo ""
    echo "Checking Docker image..."

    # Use bulk-patterns image if available, then fixed, then venv-enabled, otherwise build
    if nerdctl images | grep -q "prism-api-gpu.*production-bulk-patterns"; then
        IMAGE_TAG="production-bulk-patterns"
        print_status "Using bulk-patterns Docker image with all fixes"
    elif nerdctl images | grep -q "prism-api-gpu.*production-venv-fixed"; then
        IMAGE_TAG="production-venv-fixed"
        print_status "Using venv-fixed Docker image"
    elif nerdctl images | grep -q "prism-api-gpu.*production-venv"; then
        IMAGE_TAG="production-venv"
        print_status "Using venv-enabled Docker image"
    elif nerdctl images | grep -q "prism-api-gpu.*production-v440"; then
        IMAGE_TAG="production-v440"
        print_status "Using standard Docker image"
    else
        print_warning "Docker image not found. Building..."
        nerdctl build -t prism-api-gpu:production-bulk-patterns -f Dockerfile.production .
        IMAGE_TAG="production-bulk-patterns"
    fi
}

# Start API server container
start_api_server() {
    echo ""
    echo "Starting PRISM API server (GPU mode with host networking)..."

    print_status "Using host network configuration"

    # Start the container with host networking
    # API server will run on port 8092 (avoiding conflicts)
    nerdctl run -d \
        --name prism-api \
        --gpus all \
        --network host \
        -v "$HOME/.local/share/prism_mcp:/data" \
        -v "$HOME/.local/share/prism_mcp/models:/models" \
        -v "$(pwd)/config:/app/config:ro" \
        -e PRISM_DATA_DIR=/data \
        -e CUDA_VISIBLE_DEVICES=0 \
        -e PRISM_API_PORT=8092 \
        -e PRISM_CONFIG=/app/config/config_container.yaml \
        prism-api-gpu:${IMAGE_TAG} \
        python -m prism_mcp.interfaces.http_api --port 8092

    print_status "API server container started"
}

# Monitor API server startup
monitor_api_startup() {
    echo ""
    echo "Monitoring API server startup (this will take 2-3 minutes for model loading)..."
    echo "Following logs (press Ctrl+C to stop following, server will continue running)..."
    echo ""

    # Follow logs until user interrupts or server is ready
    timeout 300 bash -c '
        while true; do
            if nerdctl logs prism-api 2>&1 | grep -q "Application startup complete"; then
                echo ""
                echo "API server is ready!"
                break
            fi
            sleep 5
        done
    ' &

    MONITOR_PID=$!

    # Show logs
    nerdctl logs prism-api -f &
    LOGS_PID=$!

    # Wait for monitor to complete or user interrupt
    trap "kill $LOGS_PID 2>/dev/null; kill $MONITOR_PID 2>/dev/null" INT
    wait $MONITOR_PID 2>/dev/null || true
    kill $LOGS_PID 2>/dev/null || true
    trap - INT
}

# Test API health
test_api_health() {
    echo ""
    echo "Testing API health..."

    if curl -s http://localhost:8092/health | grep -q "healthy"; then
        print_status "API server is healthy"

        # Get detailed health status
        echo ""
        echo "Detailed health status:"
        curl -s http://localhost:8092/api/health/detailed | python3 -m json.tool | head -20 || true
    else
        print_warning "API server health check failed (may still be starting)"
    fi
}

# Main execution
main() {
    echo "Starting PRISM GPU system with host networking..."
    echo ""

    # Run all steps
    check_gpu
    cleanup_containers
    start_databases
    wait_for_databases
    check_docker_image
    start_api_server
    monitor_api_startup
    test_api_health

    echo ""
    echo "===================================================="
    print_status "PRISM GPU system is running!"
    echo "===================================================="
    echo ""
    echo "Services available at:"
    echo "  - API Server: http://localhost:8092"
    echo "  - Neo4j Browser: http://localhost:7474"
    echo "  - Qdrant Dashboard: http://localhost:6333/dashboard"
    echo ""
    echo "To check status: nerdctl ps | grep prism"
    echo "To view logs: nerdctl logs prism-api"
    echo "To stop: ./stop_prism.sh"
    echo ""
    echo "Next steps:"
    echo "  1. Load patterns: python -m prism_mcp.bootstrap.load_patterns_via_api --start-batch 25"
    echo "  2. Index code: python -m prism_mcp.core.index_manager /path/to/code"
    echo ""
}

# Run main function
main "$@"