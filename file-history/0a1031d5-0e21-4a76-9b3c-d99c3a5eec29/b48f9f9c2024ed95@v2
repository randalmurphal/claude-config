"""
API-based reranking providers (Tier 0 - PREMIUM_API)

Provides wrappers for:
- Jina AI Reranker (jina-reranker-v2-base-multilingual, jina-reranker-m0)
- Future: Cohere Rerank, Voyage Rerank
"""

import logging
from typing import List, Tuple

logger = logging.getLogger(__name__)


class JinaReranker:
    """
    Jina AI reranker client

    Models:
    - jina-reranker-v2-base-multilingual: Fast, multilingual (FREE tier)
    - jina-reranker-m0: Multimodal, SOTA performance

    Free tier: 10M tokens
    """

    def __init__(self, api_key: str, model: str = "jina-reranker-v2-base-multilingual"):
        """
        Initialize Jina reranker client

        Args:
            api_key: Jina API key (get from https://jina.ai/)
            model: Reranker model to use
        """
        self.api_key = api_key
        self.model = model

        # Check for requests library
        try:
            import requests
            self.requests = requests
            logger.info(f"Initialized Jina Reranker client (model: {model})")
        except ImportError:
            logger.error("requests package not installed")
            raise RuntimeError("requests package required for Jina reranker")

        # API endpoint
        self.base_url = "https://api.jina.ai/v1"

        # Track usage
        self.total_tokens_used = 0
        self.total_requests = 0

    def rerank(
        self,
        query: str,
        documents: List[str],
        top_n: int = 10,
        timeout: int = 30
    ) -> List[Tuple[int, float]]:
        """
        Rerank documents by relevance to query

        Args:
            query: Query text
            documents: List of document texts to rerank
            top_n: Number of top results to return
            timeout: Request timeout in seconds

        Returns:
            List of (original_index, relevance_score) tuples, sorted by relevance
        """
        if not documents:
            return []

        # Filter out empty documents
        valid_docs = []
        doc_mapping = []  # Maps filtered index â†’ original index

        for i, doc in enumerate(documents):
            if doc and doc.strip():
                valid_docs.append(doc)
                doc_mapping.append(i)

        if not valid_docs:
            return []

        try:
            response = self.requests.post(
                f"{self.base_url}/rerank",
                headers={
                    'Content-Type': 'application/json',
                    'Authorization': f'Bearer {self.api_key}'
                },
                json={
                    'model': self.model,
                    'query': query,
                    'documents': valid_docs,
                    'top_n': min(top_n, len(valid_docs)),
                },
                timeout=timeout
            )

            if response.status_code != 200:
                logger.error(f"Jina reranker API error: {response.status_code} - {response.text}")
                # Fallback: return original order with default scores
                return [(i, 1.0 / (i + 1)) for i in range(min(top_n, len(doc_mapping)))]

            result = response.json()

            # Track usage
            usage = result.get('usage', {})
            tokens_used = usage.get('total_tokens', 0)
            self.total_tokens_used += tokens_used
            self.total_requests += 1

            # Map filtered indices back to original indices
            reranked = []
            for item in result.get('results', []):
                filtered_idx = item.get('index', -1)
                relevance = item.get('relevance_score', 0.0)

                if 0 <= filtered_idx < len(doc_mapping):
                    original_idx = doc_mapping[filtered_idx]
                    reranked.append((original_idx, relevance))

            return reranked

        except Exception as e:
            logger.error(f"Jina reranker error: {e}")
            # Fallback: return original order
            return [(i, 1.0 / (i + 1)) for i in range(min(top_n, len(doc_mapping)))]

    def rerank_with_objects(
        self,
        query: str,
        objects: List[dict],
        text_field: str = 'text',
        top_n: int = 10
    ) -> List[Tuple[dict, float]]:
        """
        Rerank objects by extracting text field

        Args:
            query: Query text
            objects: List of objects with text field
            text_field: Field name containing text to rerank
            top_n: Number of top results to return

        Returns:
            List of (object, relevance_score) tuples
        """
        # Extract texts
        texts = [obj.get(text_field, '') for obj in objects]

        # Rerank
        reranked_indices = self.rerank(query, texts, top_n=top_n)

        # Return objects with scores
        return [(objects[idx], score) for idx, score in reranked_indices]

    def get_usage_stats(self) -> dict:
        """Get usage statistics"""
        return {
            'total_tokens': self.total_tokens_used,
            'total_requests': self.total_requests,
            'remaining_free_tokens': max(0, 10_000_000 - self.total_tokens_used),
            'model': self.model,
        }


class CohereReranker:
    """
    Cohere Rerank API client (placeholder for future)

    Could add support for:
    - rerank-english-v3.0: English reranking
    - rerank-multilingual-v3.0: Multilingual
    """

    def __init__(self, api_key: str):
        self.api_key = api_key
        logger.warning("Cohere reranker not yet implemented")
        raise NotImplementedError("Cohere reranker support coming soon")


class VoyageReranker:
    """
    Voyage Rerank API client (placeholder for future)

    Could add support for:
    - rerank-2: Latest multilingual reranker
    - rerank-2-lite: Faster, lighter version
    """

    def __init__(self, api_key: str):
        self.api_key = api_key
        logger.warning("Voyage reranker not yet implemented")
        raise NotImplementedError("Voyage reranker support coming soon")