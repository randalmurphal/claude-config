"""
Pattern extraction from release notes.

Extracts code patterns (function names, methods) from release notes
that developers should search for in their codebase.
"""

import re
from dataclasses import dataclass
from typing import List, Dict


@dataclass
class Pattern:
    """Extracted code pattern."""
    pattern: str
    confidence: float  # 0.0 to 1.0
    reason: str
    from_version: str


class PatternExtractor:
    """Extract code patterns from release notes."""

    def __init__(self):
        """Initialize pattern extractor."""
        self.security_keywords = [
            'sql injection',
            'xss',
            'csrf',
            'security',
            'vulnerability',
            'exploit',
            'injection'
        ]

    def extract_patterns(
        self,
        release_notes: str,
        version: str
    ) -> List[Pattern]:
        """
        Extract code patterns from release notes using rule-based approach.

        Args:
            release_notes: Release note text
            version: Version this release is from

        Returns:
            List of extracted patterns
        """
        patterns = []
        notes_lower = release_notes.lower()

        # Rule 1: Function/method mentions
        # Matches: Query(), Body(), StreamingResponse(), etc.
        function_mentions = re.findall(
            r'`?([A-Z][a-zA-Z]+)\(\)`?',
            release_notes
        )

        for func in function_mentions:
            patterns.append(Pattern(
                pattern=f'{func}(',
                confidence=0.8,
                reason=f'Function {func}() mentioned in release notes',
                from_version=version
            ))

        # Rule 2: Security keywords + context
        # If mentions "SQL injection" + "query" â†’ likely Query() related
        if any(word in notes_lower for word in self.security_keywords):
            # Look for common parameter names
            context_keywords = {
                'query': 'Query(',
                'body': 'Body(',
                'header': 'Header(',
                'cookie': 'Cookie(',
                'form': 'Form(',
            }

            for keyword, pattern_str in context_keywords.items():
                if keyword in notes_lower:
                    # Check if we already added this from Rule 1
                    if not any(p.pattern == pattern_str for p in patterns):
                        patterns.append(Pattern(
                            pattern=pattern_str,
                            confidence=0.6,
                            reason=f'Security issue + {keyword} mentioned',
                            from_version=version
                        ))

        # Rule 3: Deprecation notices
        # Matches: "Deprecated: Body()" or "Body() is deprecated"
        deprecated = re.findall(
            r'deprecated[:\s]+`?([A-Z][a-zA-Z]+)\(\)`?',
            release_notes,
            re.IGNORECASE
        )

        for func in deprecated:
            # Check if already added
            pattern_str = f'{func}('
            if not any(p.pattern == pattern_str for p in patterns):
                patterns.append(Pattern(
                    pattern=pattern_str,
                    confidence=0.9,
                    reason=f'{func}() is deprecated',
                    from_version=version
                ))

        return patterns

    def deduplicate_patterns(
        self,
        patterns: List[Pattern]
    ) -> Dict[str, Pattern]:
        """
        Deduplicate patterns, keeping highest confidence.

        Args:
            patterns: List of patterns (possibly with duplicates)

        Returns:
            Dictionary of unique patterns (pattern_str -> Pattern)
        """
        unique = {}

        for pattern in patterns:
            if pattern.pattern not in unique:
                unique[pattern.pattern] = pattern
            else:
                # Keep highest confidence
                if pattern.confidence > unique[pattern.pattern].confidence:
                    unique[pattern.pattern] = pattern

        return unique