"""
Comprehensive tests for PersonalKnowledgeEngine.

Tests all 19 methods across 6 categories:
1. Preferences (store, get, update_evidence)
2. Tech opinions (store, get_stack)
3. Lessons (store, query)
4. Terms (store, translate, get)
5. Threads (create, continue, get_active, update_status, get_context)
6. Unified context (get_user_context - CRITICAL)

Follows NO DEFAULTS philosophy - crashes loudly on missing required params.
Tests both happy paths and error cases.
Aim: 95%+ coverage.
"""

import pytest
import uuid
from datetime import datetime, timedelta
from unittest.mock import Mock, MagicMock, patch, AsyncMock
import numpy as np

from prism_mcp.core.personal_knowledge_engine import PersonalKnowledgeEngine


@pytest.fixture
def mock_qdrant():
    """Mock QdrantManager for testing."""
    qdrant = Mock()
    qdrant.get_collection_for_memory_type = Mock(return_value='memories_e5')
    qdrant.ensure_collection = Mock()
    qdrant.client = Mock()
    qdrant.client.upsert = Mock()
    qdrant.client.scroll = Mock(return_value=([], None))
    qdrant.client.retrieve = Mock(return_value=[])
    qdrant.client.set_payload = Mock()
    qdrant.client.search = Mock(return_value=[])
    return qdrant


@pytest.fixture
def mock_neo4j():
    """Mock Neo4jManager for testing."""
    neo4j = Mock()
    neo4j.create_node = Mock()
    neo4j.create_relationship = Mock()
    neo4j.query = Mock(return_value=[])
    neo4j.close = Mock()
    return neo4j


@pytest.fixture
def mock_embedder():
    """Mock embedder for testing."""
    embedder = Mock()
    embedder.generate_embedding = Mock(
        return_value=np.random.rand(4096).astype(np.float32)
    )
    embedder.embed_with_e5 = Mock(
        return_value=np.random.rand(4096).astype(np.float32)
    )
    return embedder


@pytest.fixture
def mock_prism_engine(mock_qdrant, mock_neo4j, mock_embedder):
    """Mock PrismEngine for testing."""
    prism = Mock()
    prism.qdrant = mock_qdrant
    prism.neo4j = mock_neo4j
    prism.embedder = mock_embedder
    prism.store_memory = Mock()
    prism.retrieve_memory = Mock(return_value=[])
    prism.close = Mock()
    return prism


@pytest.fixture
def mock_preference_manager():
    """Mock PreferenceManager for testing."""
    manager = Mock()
    manager.store_personal_preference = AsyncMock(
        return_value={'preference_id': str(uuid.uuid4()), 'status': 'approved'}
    )
    manager.get_personal_preferences = AsyncMock(return_value={'preferences': []})
    return manager


@pytest.fixture
def mock_relationship_manager(mock_neo4j):
    """Mock RelationshipManager for testing."""
    manager = Mock()
    manager.create_typed_relationship = Mock()
    manager.close = Mock()
    return manager


@pytest.fixture
def mock_id_manager():
    """Mock PersonalIDManager for testing."""
    manager = Mock()
    manager.generate_personal_id = Mock(side_effect=lambda prefix: str(uuid.uuid4()))
    return manager


@pytest.fixture
def personal_knowledge_engine(
    mock_prism_engine,
    mock_preference_manager,
    mock_relationship_manager,
    mock_id_manager,
):
    """Create PersonalKnowledgeEngine with all dependencies mocked."""
    with patch(
        'prism_mcp.core.personal_knowledge_engine.PrismEngine',
        return_value=mock_prism_engine,
    ), patch(
        'prism_mcp.core.personal_knowledge_engine.PreferenceManager',
        return_value=mock_preference_manager,
    ), patch(
        'prism_mcp.core.personal_knowledge_engine.RelationshipManager',
        return_value=mock_relationship_manager,
    ), patch(
        'prism_mcp.core.personal_knowledge_engine.PersonalIDManager',
        return_value=mock_id_manager,
    ):
        engine = PersonalKnowledgeEngine()
        engine.prism = mock_prism_engine
        engine.qdrant = mock_prism_engine.qdrant
        engine.neo4j = mock_prism_engine.neo4j
        engine.embedder = mock_prism_engine.embedder
        engine.preference_manager = mock_preference_manager
        engine.relationship_manager = mock_relationship_manager
        engine.id_manager = mock_id_manager
        return engine


# ═══════════════════════════════════════════════════════════════════
# PREFERENCE MANAGEMENT TESTS
# ═══════════════════════════════════════════════════════════════════


class TestStorePreference:
    """Test store_preference() method."""

    def test_store_preference_success(
        self, personal_knowledge_engine, mock_preference_manager
    ):
        """store_preference() succeeds with all required fields."""
        result = personal_knowledge_engine.store_preference(
            category='coding_style',
            scope='global',
            value='Always use type hints',
            reasoning='Improves code clarity',
            session_id='session-123',
        )

        assert isinstance(result, str)
        mock_preference_manager.store_personal_preference.assert_called_once()

    def test_store_preference_missing_category_crashes(
        self, personal_knowledge_engine
    ):
        """store_preference() crashes if category missing (NO DEFAULTS)."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_preference(
                category='',
                scope='global',
                value='Test',
                reasoning='Test',
                session_id='session-123',
            )

        assert 'category required' in str(exc_info.value)

    def test_store_preference_missing_scope_crashes(self, personal_knowledge_engine):
        """store_preference() crashes if scope missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_preference(
                category='coding_style',
                scope='',
                value='Test',
                reasoning='Test',
                session_id='session-123',
            )

        assert 'scope required' in str(exc_info.value)

    def test_store_preference_missing_value_crashes(self, personal_knowledge_engine):
        """store_preference() crashes if value missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_preference(
                category='coding_style',
                scope='global',
                value='',
                reasoning='Test',
                session_id='session-123',
            )

        assert 'value required' in str(exc_info.value)

    def test_store_preference_missing_reasoning_crashes(
        self, personal_knowledge_engine
    ):
        """store_preference() crashes if reasoning missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_preference(
                category='coding_style',
                scope='global',
                value='Test',
                reasoning='',
                session_id='session-123',
            )

        assert 'reasoning required' in str(exc_info.value)

    def test_store_preference_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """store_preference() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_preference(
                category='coding_style',
                scope='global',
                value='Test',
                reasoning='Test',
                session_id='',
            )

        assert 'session_id required' in str(exc_info.value)


class TestGetPreferences:
    """Test get_preferences() method."""

    def test_get_preferences_success(
        self, personal_knowledge_engine, mock_preference_manager
    ):
        """get_preferences() returns sorted preferences."""
        mock_preference_manager.get_personal_preferences.return_value = {
            'preferences': [
                {'scope': 'global', 'confidence': 0.8, 'evidence_count': 5},
                {'scope': 'project', 'confidence': 0.9, 'evidence_count': 10},
            ]
        }

        result = personal_knowledge_engine.get_preferences(session_id='session-123')

        assert len(result) == 2
        assert result[0]['scope'] == 'project'  # Higher priority
        mock_preference_manager.get_personal_preferences.assert_called_once()

    def test_get_preferences_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """get_preferences() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_preferences(session_id='')

        assert 'session_id required' in str(exc_info.value)

    def test_get_preferences_with_filters(
        self, personal_knowledge_engine, mock_preference_manager
    ):
        """get_preferences() passes filters to PreferenceManager."""
        personal_knowledge_engine.get_preferences(
            session_id='session-123',
            category='coding_style',
            scope='global',
            project_id='proj-456',
        )

        call_args = mock_preference_manager.get_personal_preferences.call_args[1]
        assert call_args['category'] == 'coding_style'
        assert call_args['scope'] == 'global'
        assert call_args['project_id'] == 'proj-456'


class TestUpdatePreferenceEvidence:
    """Test update_preference_evidence() method."""

    def test_update_preference_evidence_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """update_preference_evidence() increments evidence count."""
        pref_id = str(uuid.uuid4())
        mock_point = Mock()
        mock_point.payload = {'evidence_count': 5, 'access_count': 10}
        mock_qdrant.client.retrieve.return_value = [mock_point]

        personal_knowledge_engine.update_preference_evidence(
            preference_id=pref_id, session_id='session-123'
        )

        mock_qdrant.client.set_payload.assert_called_once()
        call_args = mock_qdrant.client.set_payload.call_args[1]
        assert call_args['payload']['evidence_count'] == 6
        assert call_args['payload']['access_count'] == 11

        mock_neo4j.query.assert_called_once()

    def test_update_preference_evidence_missing_preference_id_crashes(
        self, personal_knowledge_engine
    ):
        """update_preference_evidence() crashes if preference_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.update_preference_evidence(
                preference_id='', session_id='session-123'
            )

        assert 'preference_id required' in str(exc_info.value)

    def test_update_preference_evidence_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """update_preference_evidence() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.update_preference_evidence(
                preference_id=str(uuid.uuid4()), session_id=''
            )

        assert 'session_id required' in str(exc_info.value)

    def test_update_preference_evidence_not_found_crashes(
        self, personal_knowledge_engine, mock_qdrant
    ):
        """update_preference_evidence() crashes if preference not found."""
        mock_qdrant.client.retrieve.return_value = []

        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.update_preference_evidence(
                preference_id=str(uuid.uuid4()), session_id='session-123'
            )

        assert 'Preference not found' in str(exc_info.value)


# ═══════════════════════════════════════════════════════════════════
# TECH OPINION MANAGEMENT TESTS
# ═══════════════════════════════════════════════════════════════════


class TestStoreTechOpinion:
    """Test store_tech_opinion() method."""

    def test_store_tech_opinion_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """store_tech_opinion() stores opinion successfully."""
        result = personal_knowledge_engine.store_tech_opinion(
            tech_name='FastAPI',
            sentiment='love',
            reasoning='Great async support',
            session_id='session-123',
        )

        assert isinstance(result, str)
        mock_qdrant.client.upsert.assert_called_once()
        mock_neo4j.create_node.assert_called_once()

    def test_store_tech_opinion_missing_tech_name_crashes(
        self, personal_knowledge_engine
    ):
        """store_tech_opinion() crashes if tech_name missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_tech_opinion(
                tech_name='',
                sentiment='love',
                reasoning='Test',
                session_id='session-123',
            )

        assert 'tech_name required' in str(exc_info.value)

    def test_store_tech_opinion_missing_sentiment_crashes(
        self, personal_knowledge_engine
    ):
        """store_tech_opinion() crashes if sentiment missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_tech_opinion(
                tech_name='FastAPI',
                sentiment='',
                reasoning='Test',
                session_id='session-123',
            )

        assert 'sentiment required' in str(exc_info.value)

    def test_store_tech_opinion_missing_reasoning_crashes(
        self, personal_knowledge_engine
    ):
        """store_tech_opinion() crashes if reasoning missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_tech_opinion(
                tech_name='FastAPI',
                sentiment='love',
                reasoning='',
                session_id='session-123',
            )

        assert 'reasoning required' in str(exc_info.value)

    def test_store_tech_opinion_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """store_tech_opinion() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_tech_opinion(
                tech_name='FastAPI',
                sentiment='love',
                reasoning='Test',
                session_id='',
            )

        assert 'session_id required' in str(exc_info.value)

    def test_store_tech_opinion_invalid_sentiment_crashes(
        self, personal_knowledge_engine
    ):
        """store_tech_opinion() crashes if sentiment invalid."""
        with pytest.raises(ValueError) as exc_info:
            personal_knowledge_engine.store_tech_opinion(
                tech_name='FastAPI',
                sentiment='invalid',
                reasoning='Test',
                session_id='session-123',
            )

        assert 'sentiment must be one of' in str(exc_info.value)

    def test_store_tech_opinion_valid_sentiments(
        self, personal_knowledge_engine, mock_qdrant
    ):
        """store_tech_opinion() accepts all valid sentiments."""
        valid_sentiments = ['love', 'prefer', 'neutral', 'avoid', 'hate']

        for sentiment in valid_sentiments:
            mock_qdrant.client.upsert.reset_mock()

            result = personal_knowledge_engine.store_tech_opinion(
                tech_name='TestTech',
                sentiment=sentiment,
                reasoning='Test',
                session_id='session-123',
            )

            assert isinstance(result, str)
            mock_qdrant.client.upsert.assert_called_once()

    def test_store_tech_opinion_with_evolution(
        self, personal_knowledge_engine, mock_neo4j, mock_relationship_manager
    ):
        """store_tech_opinion() creates EVOLVED_FROM relationship."""
        prev_id = str(uuid.uuid4())
        mock_neo4j.query.return_value = [{'prev_id': prev_id}]

        personal_knowledge_engine.store_tech_opinion(
            tech_name='FastAPI',
            sentiment='prefer',
            reasoning='Still good but found issues',
            session_id='session-123',
            changed_from='love',
        )

        mock_relationship_manager.create_typed_relationship.assert_called_once()


class TestGetTechStack:
    """Test get_tech_stack() method."""

    def test_get_tech_stack_success(self, personal_knowledge_engine, mock_qdrant):
        """get_tech_stack() returns categorized tech opinions."""
        mock_point1 = Mock()
        mock_point1.payload = {
            'memory_id': 'op1',
            'tech_name': 'FastAPI',
            'sentiment': 'love',
            'reasoning': 'Great',
            'alternatives_considered': [],
            'project_id': None,
            'created_at': datetime.now().isoformat(),
        }
        mock_point2 = Mock()
        mock_point2.payload = {
            'memory_id': 'op2',
            'tech_name': 'Django',
            'sentiment': 'avoid',
            'reasoning': 'Too heavy',
            'alternatives_considered': [],
            'project_id': None,
            'created_at': datetime.now().isoformat(),
        }
        mock_qdrant.client.scroll.return_value = ([mock_point1, mock_point2], None)

        result = personal_knowledge_engine.get_tech_stack(session_id='session-123')

        assert len(result['preferred']) == 1
        assert len(result['avoided']) == 1
        assert len(result['neutral']) == 0
        assert result['metadata']['total_technologies'] == 2

    def test_get_tech_stack_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """get_tech_stack() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_tech_stack(session_id='')

        assert 'session_id required' in str(exc_info.value)


# ═══════════════════════════════════════════════════════════════════
# LESSON MANAGEMENT TESTS
# ═══════════════════════════════════════════════════════════════════


class TestStoreLesson:
    """Test store_lesson() method."""

    def test_store_lesson_success(
        self, personal_knowledge_engine, mock_prism_engine, mock_neo4j
    ):
        """store_lesson() stores lesson successfully."""
        mock_memory = Mock()
        mock_memory.memory_id = 'lesson-123'
        mock_prism_engine.store_memory.return_value = mock_memory

        result = personal_knowledge_engine.store_lesson(
            category='debugging',
            problem_context='Database connection issue',
            approach_tried='Restarted service',
            outcome='success',
            learning='Always check connection pool limits',
            session_id='session-123',
        )

        assert result == 'lesson-123'
        mock_prism_engine.store_memory.assert_called_once()
        mock_neo4j.query.assert_called_once()

    def test_store_lesson_missing_category_crashes(self, personal_knowledge_engine):
        """store_lesson() crashes if category missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_lesson(
                category='',
                problem_context='Test',
                approach_tried='Test',
                outcome='success',
                learning='Test',
                session_id='session-123',
            )

        assert 'category required' in str(exc_info.value)

    def test_store_lesson_invalid_category_crashes(self, personal_knowledge_engine):
        """store_lesson() crashes if category invalid."""
        with pytest.raises(ValueError) as exc_info:
            personal_knowledge_engine.store_lesson(
                category='invalid',
                problem_context='Test',
                approach_tried='Test',
                outcome='success',
                learning='Test',
                session_id='session-123',
            )

        assert 'category must be one of' in str(exc_info.value)

    def test_store_lesson_invalid_outcome_crashes(self, personal_knowledge_engine):
        """store_lesson() crashes if outcome invalid."""
        with pytest.raises(ValueError) as exc_info:
            personal_knowledge_engine.store_lesson(
                category='debugging',
                problem_context='Test',
                approach_tried='Test',
                outcome='invalid',
                learning='Test',
                session_id='session-123',
            )

        assert 'outcome must be one of' in str(exc_info.value)


class TestQueryLessons:
    """Test query_lessons() method."""

    def test_query_lessons_success(
        self, personal_knowledge_engine, mock_prism_engine, mock_neo4j
    ):
        """query_lessons() returns sorted lessons."""
        mock_memory = Mock()
        mock_memory.memory_id = 'lesson-123'
        mock_memory.content = 'Lesson content'
        mock_memory.similarity_score = 0.85
        mock_memory.created_at = datetime.now()
        mock_memory.project_id = 'proj-456'
        mock_prism_engine.retrieve_memory.return_value = [mock_memory]

        mock_neo4j.query.return_value = [
            {
                'category': 'debugging',
                'outcome': 'success',
                'user_id': 'user-789',
                'applicable_to': ['backend', 'database'],
            }
        ]

        result = personal_knowledge_engine.query_lessons(
            query='database issues', session_id='session-123'
        )

        assert len(result) == 1
        assert result[0]['lesson_id'] == 'lesson-123'
        assert result[0]['outcome'] == 'success'

    def test_query_lessons_missing_query_crashes(self, personal_knowledge_engine):
        """query_lessons() crashes if query missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.query_lessons(query='', session_id='session-123')

        assert 'query required' in str(exc_info.value)

    def test_query_lessons_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """query_lessons() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.query_lessons(query='test', session_id='')

        assert 'session_id required' in str(exc_info.value)


# ═══════════════════════════════════════════════════════════════════
# TERMINOLOGY MANAGEMENT TESTS
# ═══════════════════════════════════════════════════════════════════


class TestStoreUserTerm:
    """Test store_user_term() method."""

    def test_store_user_term_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """store_user_term() stores term successfully."""
        result = personal_knowledge_engine.store_user_term(
            user_term='the auth thing',
            canonical_term='JWT middleware',
            context='authentication',
            session_id='session-123',
        )

        assert isinstance(result, str)
        mock_qdrant.client.upsert.assert_called_once()
        mock_neo4j.create_node.assert_called_once()

    def test_store_user_term_missing_user_term_crashes(
        self, personal_knowledge_engine
    ):
        """store_user_term() crashes if user_term missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_user_term(
                user_term='',
                canonical_term='Test',
                context='test',
                session_id='session-123',
            )

        assert 'user_term required' in str(exc_info.value)

    def test_store_user_term_missing_canonical_term_crashes(
        self, personal_knowledge_engine
    ):
        """store_user_term() crashes if canonical_term missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_user_term(
                user_term='test',
                canonical_term='',
                context='test',
                session_id='session-123',
            )

        assert 'canonical_term required' in str(exc_info.value)

    def test_store_user_term_missing_context_crashes(self, personal_knowledge_engine):
        """store_user_term() crashes if context missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.store_user_term(
                user_term='test',
                canonical_term='Test',
                context='',
                session_id='session-123',
            )

        assert 'context required' in str(exc_info.value)


class TestTranslateTerm:
    """Test translate_term() method."""

    def test_translate_term_success(self, personal_knowledge_engine, mock_qdrant):
        """translate_term() returns canonical term."""
        mock_result = Mock()
        mock_result.payload = {
            'memory_id': 'term-123',
            'canonical_term': 'JWT middleware',
            'usage_count': 5,
        }
        mock_result.score = 0.92
        mock_qdrant.client.search.return_value = [mock_result]

        result = personal_knowledge_engine.translate_term(
            user_term='the auth thing', session_id='session-123'
        )

        assert result == 'JWT middleware'
        mock_qdrant.client.set_payload.assert_called_once()

    def test_translate_term_not_found_returns_none(
        self, personal_knowledge_engine, mock_qdrant
    ):
        """translate_term() returns None if no match found."""
        mock_qdrant.client.search.return_value = []

        result = personal_knowledge_engine.translate_term(
            user_term='unknown term', session_id='session-123'
        )

        assert result is None

    def test_translate_term_missing_user_term_crashes(self, personal_knowledge_engine):
        """translate_term() crashes if user_term missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.translate_term(user_term='', session_id='session-123')

        assert 'user_term required' in str(exc_info.value)


class TestGetUserTerms:
    """Test get_user_terms() method."""

    def test_get_user_terms_success(self, personal_knowledge_engine, mock_qdrant):
        """get_user_terms() returns sorted terms."""
        mock_point1 = Mock()
        mock_point1.payload = {
            'memory_id': 'term1',
            'user_term': 'auth thing',
            'canonical_term': 'JWT middleware',
            'context': 'authentication',
            'definition': 'Test',
            'aliases': [],
            'related_files': [],
            'usage_count': 10,
            'created_at': datetime.now().isoformat(),
        }
        mock_point2 = Mock()
        mock_point2.payload = {
            'memory_id': 'term2',
            'user_term': 'db stuff',
            'canonical_term': 'Database manager',
            'context': 'storage',
            'definition': 'Test',
            'aliases': [],
            'related_files': [],
            'usage_count': 5,
            'created_at': datetime.now().isoformat(),
        }
        mock_qdrant.client.scroll.return_value = ([mock_point1, mock_point2], None)

        result = personal_knowledge_engine.get_user_terms(session_id='session-123')

        assert len(result) == 2
        assert result[0]['usage_count'] == 10  # Sorted by usage
        assert result[1]['usage_count'] == 5

    def test_get_user_terms_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """get_user_terms() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_user_terms(session_id='')

        assert 'session_id required' in str(exc_info.value)


# ═══════════════════════════════════════════════════════════════════
# THREAD MANAGEMENT TESTS
# ═══════════════════════════════════════════════════════════════════


class TestCreateThread:
    """Test create_thread() method."""

    def test_create_thread_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """create_thread() creates thread successfully."""
        result = personal_knowledge_engine.create_thread(
            topic='Refactoring auth module', session_id='session-123'
        )

        assert isinstance(result, str)
        mock_qdrant.client.upsert.assert_called_once()
        mock_neo4j.create_node.assert_called_once()

    def test_create_thread_missing_topic_crashes(self, personal_knowledge_engine):
        """create_thread() crashes if topic missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.create_thread(topic='', session_id='session-123')

        assert 'topic required' in str(exc_info.value)

    def test_create_thread_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """create_thread() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.create_thread(topic='Test', session_id='')

        assert 'session_id required' in str(exc_info.value)


class TestContinueThread:
    """Test continue_thread() method."""

    def test_continue_thread_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """continue_thread() adds memory to thread."""
        thread_id = str(uuid.uuid4())
        mock_point = Mock()
        mock_point.payload = {'access_count': 5}
        mock_qdrant.client.retrieve.return_value = [mock_point]

        personal_knowledge_engine.continue_thread(
            thread_id=thread_id, memory_id='mem-123', session_id='session-123'
        )

        mock_neo4j.create_relationship.assert_called_once()
        mock_qdrant.client.set_payload.assert_called_once()

    def test_continue_thread_missing_thread_id_crashes(
        self, personal_knowledge_engine
    ):
        """continue_thread() crashes if thread_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.continue_thread(
                thread_id='', memory_id='mem-123', session_id='session-123'
            )

        assert 'thread_id required' in str(exc_info.value)

    def test_continue_thread_missing_memory_id_crashes(
        self, personal_knowledge_engine
    ):
        """continue_thread() crashes if memory_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.continue_thread(
                thread_id=str(uuid.uuid4()), memory_id='', session_id='session-123'
            )

        assert 'memory_id required' in str(exc_info.value)

    def test_continue_thread_not_found_crashes(
        self, personal_knowledge_engine, mock_qdrant
    ):
        """continue_thread() crashes if thread not found."""
        mock_qdrant.client.retrieve.return_value = []

        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.continue_thread(
                thread_id=str(uuid.uuid4()),
                memory_id='mem-123',
                session_id='session-123',
            )

        assert 'Thread not found' in str(exc_info.value)


class TestGetActiveThreads:
    """Test get_active_threads() method."""

    def test_get_active_threads_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """get_active_threads() returns active threads."""
        mock_point = Mock()
        mock_point.payload = {
            'thread_id': 'thread-123',
            'thread_topic': 'Refactoring',
            'thread_status': 'open',
            'started_at': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
        }
        mock_qdrant.client.scroll.return_value = ([mock_point], None)
        mock_neo4j.query.return_value = [{'count': 3}]

        result = personal_knowledge_engine.get_active_threads(session_id='session-123')

        assert len(result) == 1
        assert result[0]['thread_id'] == 'thread-123'
        assert result[0]['memory_count'] == 3

    def test_get_active_threads_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """get_active_threads() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_active_threads(session_id='')

        assert 'session_id required' in str(exc_info.value)


class TestUpdateThreadStatus:
    """Test update_thread_status() method."""

    def test_update_thread_status_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """update_thread_status() updates status successfully."""
        thread_id = str(uuid.uuid4())
        mock_point = Mock()
        mock_qdrant.client.retrieve.return_value = [mock_point]

        personal_knowledge_engine.update_thread_status(
            thread_id=thread_id, status='resolved', session_id='session-123', resolution='Fixed'
        )

        mock_qdrant.client.set_payload.assert_called_once()
        mock_neo4j.query.assert_called_once()

    def test_update_thread_status_missing_thread_id_crashes(
        self, personal_knowledge_engine
    ):
        """update_thread_status() crashes if thread_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.update_thread_status(
                thread_id='', status='resolved', session_id='session-123'
            )

        assert 'thread_id required' in str(exc_info.value)

    def test_update_thread_status_invalid_status_crashes(
        self, personal_knowledge_engine
    ):
        """update_thread_status() crashes if status invalid."""
        with pytest.raises(ValueError) as exc_info:
            personal_knowledge_engine.update_thread_status(
                thread_id=str(uuid.uuid4()),
                status='invalid',
                session_id='session-123',
            )

        assert 'status must be one of' in str(exc_info.value)

    def test_update_thread_status_resolved_without_resolution_crashes(
        self, personal_knowledge_engine
    ):
        """update_thread_status() crashes if resolved without resolution."""
        with pytest.raises(ValueError) as exc_info:
            personal_knowledge_engine.update_thread_status(
                thread_id=str(uuid.uuid4()),
                status='resolved',
                session_id='session-123',
            )

        assert 'resolution required' in str(exc_info.value)


class TestGetThreadContext:
    """Test get_thread_context() method."""

    def test_get_thread_context_success(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """get_thread_context() returns complete thread context."""
        thread_id = str(uuid.uuid4())
        mock_point = Mock()
        mock_point.payload = {
            'thread_topic': 'Refactoring',
            'thread_status': 'open',
            'started_at': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
            'key_decisions': ['Decision 1'],
            'open_questions': ['Question 1'],
        }
        mock_qdrant.client.retrieve.return_value = [mock_point]

        mock_neo4j.query.return_value = [
            {
                'm': {
                    'memory_id': 'mem-1',
                    'content': 'Memory content',
                    'type': 'note',
                    'created_at': datetime.now().isoformat(),
                }
            }
        ]

        result = personal_knowledge_engine.get_thread_context(
            thread_id=thread_id, session_id='session-123'
        )

        assert 'thread' in result
        assert 'memories' in result
        assert 'timeline' in result
        assert len(result['memories']) == 1

    def test_get_thread_context_missing_thread_id_crashes(
        self, personal_knowledge_engine
    ):
        """get_thread_context() crashes if thread_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_thread_context(
                thread_id='', session_id='session-123'
            )

        assert 'thread_id required' in str(exc_info.value)


# ═══════════════════════════════════════════════════════════════════
# UNIFIED CONTEXT RETRIEVAL TESTS (CRITICAL)
# ═══════════════════════════════════════════════════════════════════


class TestGetUserContext:
    """Test get_user_context() method - CRITICAL unified retrieval."""

    def test_get_user_context_success_all_sources(
        self, personal_knowledge_engine, mock_preference_manager, mock_prism_engine, mock_qdrant
    ):
        """get_user_context() aggregates from all sources."""
        # Mock preferences (with all required fields)
        mock_preference_manager.get_personal_preferences.return_value = {
            'preferences': [{
                'category': 'coding_style',
                'value': 'Use type hints',
                'scope': 'global',  # Required by NO DEFAULTS
                'confidence': 0.95,  # Required by NO DEFAULTS
                'evidence_count': 3  # Required by NO DEFAULTS
            }]
        }

        # Mock lessons
        mock_memory = Mock()
        mock_memory.memory_id = 'lesson-123'
        mock_memory.content = 'Lesson content'
        mock_memory.similarity_score = 0.85
        mock_memory.created_at = datetime.now()
        mock_memory.project_id = None
        mock_prism_engine.retrieve_memory.return_value = [mock_memory]

        # Mock Neo4j for lesson metadata
        mock_prism_engine.neo4j.query.return_value = [
            {
                'category': 'debugging',
                'outcome': 'success',
                'user_id': None,
                'applicable_to': [],
            }
        ]

        # Mock tech opinions scroll
        mock_opinion_point = Mock()
        mock_opinion_point.payload = {
            'memory_id': 'op-123',
            'tech_name': 'FastAPI',
            'sentiment': 'love',
            'reasoning': 'Great',
            'alternatives_considered': [],
            'project_id': None,
            'created_at': datetime.now().isoformat(),
        }

        # Mock threads scroll
        mock_thread_point = Mock()
        mock_thread_point.payload = {
            'thread_id': 'thread-123',
            'thread_topic': 'Refactoring',
            'thread_status': 'open',
            'started_at': datetime.now().isoformat(),
            'last_activity': datetime.now().isoformat(),
        }

        # Setup scroll to return different results based on filter
        def mock_scroll(collection_name, scroll_filter, **kwargs):
            must_conditions = scroll_filter.must if hasattr(scroll_filter, 'must') else []
            for cond in must_conditions:
                if isinstance(cond, dict):
                    key = cond.get('key')
                    if key == 'memory_type':
                        match_val = cond.get('match', {}).get('value')
                        if match_val == 'tech_opinion':
                            return ([mock_opinion_point], None)
                        elif match_val == 'thread':
                            return ([mock_thread_point], None)
            return ([], None)

        mock_qdrant.client.scroll.side_effect = mock_scroll

        # Mock term search
        mock_term_result = Mock()
        mock_term_result.payload = {
            'memory_id': 'term-123',
            'user_term': 'auth thing',
            'canonical_term': 'JWT middleware',
            'context': 'authentication',
        }
        mock_term_result.score = 0.88
        mock_qdrant.client.search.return_value = [mock_term_result]

        # Mock Neo4j query for evolution count and thread memory count
        def mock_neo4j_query(query, **kwargs):
            if 'EVOLVED_FROM' in query:
                return [{'count': 0}]
            elif 'CONTAINS' in query:
                return [{'count': 3}]
            else:
                return [
                    {
                        'category': 'debugging',
                        'outcome': 'success',
                        'user_id': None,
                        'applicable_to': [],
                    }
                ]

        mock_prism_engine.neo4j.query.side_effect = mock_neo4j_query

        result = personal_knowledge_engine.get_user_context(
            query='authentication refactoring', session_id='session-123'
        )

        assert 'preferences' in result
        assert 'lessons' in result
        assert 'tech_opinions' in result
        assert 'active_threads' in result
        assert 'terminology' in result
        assert 'metadata' in result
        assert result['metadata']['sources_used'] == 5

    def test_get_user_context_missing_query_crashes(self, personal_knowledge_engine):
        """get_user_context() crashes if query missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_user_context(query='', session_id='session-123')

        assert 'query required' in str(exc_info.value)

    def test_get_user_context_missing_session_id_crashes(
        self, personal_knowledge_engine
    ):
        """get_user_context() crashes if session_id missing."""
        with pytest.raises(RuntimeError) as exc_info:
            personal_knowledge_engine.get_user_context(query='test', session_id='')

        assert 'session_id required' in str(exc_info.value)

    def test_get_user_context_selective_sources(
        self, personal_knowledge_engine, mock_preference_manager
    ):
        """get_user_context() respects include flags."""
        mock_preference_manager.get_personal_preferences.return_value = {
            'preferences': [{
                'category': 'coding_style',
                'scope': 'global',  # Required by NO DEFAULTS
                'confidence': 0.90,  # Required by NO DEFAULTS
                'evidence_count': 2  # Required by NO DEFAULTS
            }]
        }

        result = personal_knowledge_engine.get_user_context(
            query='test',
            session_id='session-123',
            include_preferences=True,
            include_lessons=False,
            include_tech_opinions=False,
            include_threads=False,
            include_terminology=False,
        )

        assert len(result['preferences']) > 0
        assert len(result['lessons']) == 0
        assert len(result['tech_opinions']) == 0
        assert len(result['active_threads']) == 0
        assert len(result['terminology']) == 0
        assert result['metadata']['sources_used'] == 1

    def test_get_user_context_graceful_failure(
        self, personal_knowledge_engine, mock_preference_manager
    ):
        """get_user_context() continues if individual sources fail."""
        mock_preference_manager.get_personal_preferences.side_effect = Exception(
            'Preference error'
        )

        result = personal_knowledge_engine.get_user_context(
            query='test', session_id='session-123'
        )

        assert 'preferences' in result
        assert len(result['preferences']) == 0  # Failed but graceful


# ═══════════════════════════════════════════════════════════════════
# UTILITY TESTS
# ═══════════════════════════════════════════════════════════════════


class TestUtilityMethods:
    """Test utility methods (close, context manager)."""

    def test_close(self, personal_knowledge_engine, mock_prism_engine, mock_relationship_manager):
        """close() closes all connections."""
        personal_knowledge_engine.close()

        mock_prism_engine.close.assert_called_once()
        mock_relationship_manager.close.assert_called_once()

    def test_context_manager(
        self, mock_prism_engine, mock_preference_manager, mock_relationship_manager, mock_id_manager
    ):
        """Context manager calls close() on exit."""
        with patch(
            'prism_mcp.core.personal_knowledge_engine.PrismEngine',
            return_value=mock_prism_engine,
        ), patch(
            'prism_mcp.core.personal_knowledge_engine.PreferenceManager',
            return_value=mock_preference_manager,
        ), patch(
            'prism_mcp.core.personal_knowledge_engine.RelationshipManager',
            return_value=mock_relationship_manager,
        ), patch(
            'prism_mcp.core.personal_knowledge_engine.PersonalIDManager',
            return_value=mock_id_manager,
        ):
            with PersonalKnowledgeEngine() as engine:
                assert engine is not None

            mock_prism_engine.close.assert_called_once()
            mock_relationship_manager.close.assert_called_once()


# ═══════════════════════════════════════════════════════════════════
# INTEGRATION TESTS
# ═══════════════════════════════════════════════════════════════════


class TestIntegration:
    """Test integration between methods (store then retrieve)."""

    def test_store_and_retrieve_preference(
        self, personal_knowledge_engine, mock_preference_manager
    ):
        """Store preference then retrieve it."""
        pref_id = str(uuid.uuid4())
        mock_preference_manager.store_personal_preference.return_value = {
            'preference_id': pref_id,
            'status': 'approved',
        }
        mock_preference_manager.get_personal_preferences.return_value = {
            'preferences': [
                {
                    'preference_id': pref_id,
                    'category': 'coding_style',
                    'value': 'Use type hints',
                    'scope': 'global',
                    'confidence': 0.9,
                    'evidence_count': 1,
                }
            ]
        }

        stored_id = personal_knowledge_engine.store_preference(
            category='coding_style',
            scope='global',
            value='Use type hints',
            reasoning='Better code',
            session_id='session-123',
        )

        preferences = personal_knowledge_engine.get_preferences(session_id='session-123')

        assert stored_id == pref_id
        assert len(preferences) == 1
        assert preferences[0]['preference_id'] == pref_id

    def test_store_and_translate_term(self, personal_knowledge_engine, mock_qdrant):
        """Store term then translate it."""
        term_id = str(uuid.uuid4())

        # Store
        personal_knowledge_engine.store_user_term(
            user_term='auth thing',
            canonical_term='JWT middleware',
            context='authentication',
            session_id='session-123',
        )

        # Setup mock for translate
        mock_result = Mock()
        mock_result.payload = {
            'memory_id': term_id,
            'canonical_term': 'JWT middleware',
            'usage_count': 1,
        }
        mock_result.score = 0.95
        mock_qdrant.client.search.return_value = [mock_result]

        # Translate
        canonical = personal_knowledge_engine.translate_term(
            user_term='auth thing', session_id='session-123'
        )

        assert canonical == 'JWT middleware'

    def test_create_and_continue_thread(
        self, personal_knowledge_engine, mock_qdrant, mock_neo4j
    ):
        """Create thread then add memory to it."""
        thread_id = str(uuid.uuid4())
        mock_qdrant.client.retrieve.return_value = [
            Mock(payload={'access_count': 0})
        ]

        # Would create thread (mocked)
        # personal_knowledge_engine.create_thread(...)

        # Continue thread
        personal_knowledge_engine.continue_thread(
            thread_id=thread_id, memory_id='mem-123', session_id='session-123'
        )

        mock_neo4j.create_relationship.assert_called_once()