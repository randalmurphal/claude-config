"""
Tests for TechStackTracker.

Tests technology extraction from tech opinions, version detection, and prioritization.
"""

import json
import pytest
from datetime import datetime
from unittest.mock import MagicMock, patch, Mock

from prism_mcp.core.tech_stack_tracker import TechStackTracker
from prism_mcp.models.tech_update import Technology


@pytest.fixture
def tech_stack_tracker():
    """Create TechStackTracker with mocked dependencies."""
    with patch('prism_mcp.core.tech_stack_tracker.get_personal_knowledge_engine') as mock_engine_fn, \
         patch('prism_mcp.core.tech_stack_tracker.RedisCache') as mock_redis_class:

        mock_engine = MagicMock()
        mock_engine_fn.return_value = mock_engine

        mock_redis = MagicMock()
        mock_redis_class.return_value = mock_redis

        tracker = TechStackTracker()
        tracker.personal_engine = mock_engine
        tracker.redis = mock_redis

        yield tracker


class TestGetUserTechStack:
    """Test get_user_tech_stack() method."""

    def test_get_tech_stack_from_opinions(self):
        """Test extracting tech stack from tech opinions."""
        with patch('prism_mcp.core.tech_stack_tracker.get_personal_knowledge_engine') as mock_engine_fn, \
             patch('prism_mcp.core.tech_stack_tracker.RedisCache') as mock_redis_class:

            mock_engine = MagicMock()
            mock_engine_fn.return_value = mock_engine

            mock_redis = MagicMock()
            mock_redis_class.return_value = mock_redis
            mock_redis.client.get.return_value = None  # No cache

            # Mock tech opinions
            mock_engine.get_tech_stack.return_value = [
                {'tech_name': 'FastAPI', 'sentiment': 'prefer'},
                {'tech_name': 'PostgreSQL', 'sentiment': 'prefer'},
                {'tech_name': 'MongoDB', 'sentiment': 'avoid'},
            ]

            tracker = TechStackTracker()
            tech_stack = tracker.get_user_tech_stack(
                session_id='session-123',
                user_id='user-456'
            )

            assert len(tech_stack) == 3
            assert all(isinstance(t, Technology) for t in tech_stack)

            # Check prioritization (prefer = priority 5)
            fastapi = next(t for t in tech_stack if t.name == 'FastAPI')
            assert fastapi.priority == 5
            assert fastapi.sentiment == 'prefer'
            assert fastapi.category == 'framework'

            mongodb = next(t for t in tech_stack if t.name == 'MongoDB')
            assert mongodb.priority == 2  # avoid = priority 2
            assert mongodb.sentiment == 'avoid'

    def test_get_tech_stack_missing_session_id_crashes(self, tech_stack_tracker):
        """Test that missing session_id crashes."""
        with pytest.raises(RuntimeError) as exc_info:
            tech_stack_tracker.get_user_tech_stack(session_id='', user_id='user-123')

        assert 'session_id required' in str(exc_info.value)

    def test_get_tech_stack_missing_user_id_crashes(self, tech_stack_tracker):
        """Test that missing user_id crashes."""
        with pytest.raises(RuntimeError) as exc_info:
            tech_stack_tracker.get_user_tech_stack(session_id='session-123', user_id='')

        assert 'user_id required' in str(exc_info.value)

    def test_get_tech_stack_uses_cache(self):
        """Test that cached tech stack is used if available."""
        with patch('prism_mcp.core.tech_stack_tracker.get_personal_knowledge_engine') as mock_engine_fn, \
             patch('prism_mcp.core.tech_stack_tracker.RedisCache') as mock_redis_class:

            mock_engine = MagicMock()
            mock_engine_fn.return_value = mock_engine

            mock_redis = MagicMock()
            mock_redis_class.return_value = mock_redis

            # Mock cached data
            cached_data = [
                {
                    'name': 'FastAPI',
                    'category': 'framework',
                    'sentiment': 'prefer',
                    'priority': 5,
                    'source': 'tech_opinions',
                    'last_checked': None,
                    'next_check': datetime.now().isoformat(),
                    'current_version': None,
                    'user_id': 'user-456',
                    'project_id': None,
                }
            ]
            mock_redis.client.get.return_value = json.dumps(cached_data)

            tracker = TechStackTracker()
            tech_stack = tracker.get_user_tech_stack(
                session_id='session-123',
                user_id='user-456'
            )

            assert len(tech_stack) == 1
            assert tech_stack[0].name == 'FastAPI'

            # Verify engine was NOT called (used cache)
            mock_engine.get_tech_stack.assert_not_called()


class TestPrioritizeChecks:
    """Test prioritize_checks() method."""

    def test_prioritize_limits_critical(self, tech_stack_tracker):
        """Test that critical technologies are limited to max_critical."""
        # Create 15 critical techs + 5 normal techs
        critical_techs = [
            Technology(name=f'Critical{i}', category='framework', priority=5, sentiment='prefer')
            for i in range(15)
        ]
        normal_techs = [
            Technology(name=f'Normal{i}', category='framework', priority=3, sentiment='neutral')
            for i in range(5)
        ]
        all_techs = critical_techs + normal_techs

        prioritized = tech_stack_tracker.prioritize_checks(all_techs, max_critical=10)

        # Should limit critical to 10, then include all 5 normal = 15 total
        assert len(prioritized) == 15
        critical_in_result = [t for t in prioritized if t.priority >= 4]
        assert len(critical_in_result) == 10

    def test_prioritize_empty_list_crashes(self, tech_stack_tracker):
        """Test that empty technologies list crashes."""
        with pytest.raises(RuntimeError) as exc_info:
            tech_stack_tracker.prioritize_checks([], max_critical=10)

        assert 'technologies list cannot be empty' in str(exc_info.value)


class TestUpdateCheckSchedule:
    """Test update_check_schedule() method."""

    def test_update_schedule_critical_update(self, tech_stack_tracker):
        """Test that critical updates trigger 12hr recheck."""
        last_checked = datetime.now()

        next_check = tech_stack_tracker.update_check_schedule(
            user_id='user-123',
            tech_name='FastAPI',
            last_checked=last_checked,
            has_critical_update=True
        )

        # Should be 12 hours from now
        delta = (next_check - last_checked).total_seconds() / 3600
        assert 11.9 < delta < 12.1  # ~12 hours

    def test_update_schedule_normal(self, tech_stack_tracker):
        """Test that normal updates trigger 24hr recheck."""
        last_checked = datetime.now()

        next_check = tech_stack_tracker.update_check_schedule(
            user_id='user-123',
            tech_name='FastAPI',
            last_checked=last_checked,
            has_critical_update=False
        )

        # Should be 24 hours from now
        delta = (next_check - last_checked).total_seconds() / 3600
        assert 23.9 < delta < 24.1  # ~24 hours


class TestDetectVersions:
    """Test detect_versions() method."""

    def test_detect_versions_missing_path_crashes(self, tech_stack_tracker):
        """Test that missing project_path crashes."""
        with pytest.raises(RuntimeError) as exc_info:
            tech_stack_tracker.detect_versions(project_path='')

        assert 'project_path required' in str(exc_info.value)

    def test_detect_versions_nonexistent_path(self, tech_stack_tracker):
        """Test that nonexistent path returns empty dict."""
        versions = tech_stack_tracker.detect_versions(project_path='/nonexistent/path')

        assert versions == {}