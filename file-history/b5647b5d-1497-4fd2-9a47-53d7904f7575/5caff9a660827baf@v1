# PRISM MCP - AI Agent Guide

## System Overview

AI memory system with 6-stage retrieval, 155K+ code patterns, and preference learning.

## Architecture

###Three-Model System (FULL Tier)
- **E5-Mistral-7B** (4096d): Semantic understanding (notes/decisions/guidance) → `memories_e5` collection
- **StarCoder2-7B** (4608d): Code pattern embeddings → `code_patterns` collection
- **BGE-Reranker-v2-m3**: Cross-encoder precision boost

### Storage
- **Qdrant** (localhost:6333): Vector embeddings, similarity search
- **Neo4j** (localhost:7687): Graph relationships, PageRank, memory tiers
- **Redis** (localhost:6379): Session cache (24h TTL), query dedup

### 6-Stage Retrieval Pipeline
1. **Semantic** → Qdrant similarity (threshold: 0.70)
2. **Graph** → Neo4j PageRank + BFS expansion (depth: 2)
3. **Context** → Role/task/project/branch filtering
4. **Temporal** → Recency + git SHA boost
5. **Diversity** → MMR + Louvain clustering
6. **Scoring** → Weighted: semantic(0.40) + graph(0.30) + temporal(0.20) + utility(0.10)

### 4-Tier Memory System
- **ANCHORS**: High-frustration (user corrections) + ADRs - never expires
- **LONGTERM**: Frequently accessed (count ≥ 5) - promotes from EPISODIC
- **EPISODIC**: Recent session discoveries - promotes from WORKING
- **WORKING**: Current session only - 72h TTL

## Key Files

### Core (`prism_mcp/core/`)
- `orchestrator.py` (1200L): Main coordinator, warm-up, retrieval orchestration
- `memory_engine.py` (950L): 4-tier memory, promotion logic
- `retrieval_coordinator.py` (900L): 6-stage pipeline execution
- `pattern_engine.py`: Hybrid AST + semantic pattern detection
- `preference_manager.py` (540L): Preference lifecycle (suggest/approve/reject/undo)
- `adr_manager.py` (411L): Architectural Decision Records in ANCHORS tier
- `duplication_detector.py` (385L): Semantic code duplication detection

### Storage (`prism_mcp/storage/`)
- `qdrant_manager.py`: Vector ops, **CRITICAL**: Use `.client` for `retrieve()`/`scroll()`, NOT wrappers
- `neo4j_manager.py`: Graph ops, use Cypher for updates (no `update_node_properties()`)
- `redis_cache.py`: Use `.client.lpush()`/`.lpop()` for list ops

### Models (`prism_mcp/models/`)
- `embedder.py`: Dual-model system, tier-aware loading
- `quantization.py`: **FIXED 2025-09-29**: Skip verification with `device_map="auto"`

### Interfaces (`prism_mcp/interfaces/`)
- `http_api.py` (2000L+): FastAPI server, 28+ endpoints (includes ADR/duplication)
- `mcp_server.py` (1040L+): MCP protocol, 23+ tools (includes ADR/duplication)

## New Components

### Intelligent Context Injection System (2025-09-30)

**Purpose**: Automatic context enrichment for user prompts based on active task, file, and phase.

**Components**:
1. **DocumentationIndexer** - Indexes all .md files into ANCHORS tier for exploration queries
2. **QueryTranslator** - Translates vague queries to technical terms using semantic search
3. **ContextWarmer** - Pre-warms Redis cache with task/file/component context (async)
4. **UserPromptEnricher** - Fast context injection in user-prompt-submit hook (<10ms)

**How It Works**:
- Orchestration events → ContextWarmer pre-warms Redis cache asynchronously
- File operations → ContextWarmer updates current file context
- User submits prompt → UserPromptEnricher reads cache and injects context (<10ms)
- Exploration queries → QueryTranslator maps vague terms to technical concepts

**Key Features**:
- **<10ms latency**: All data read from pre-warmed Redis cache (no retrieval in hook)
- **Phase-aware**: Different patterns for architecture/skeleton/implementation/validation
- **Complexity-adaptive**: Adjusts based on task size (small/medium/large/massive)
- **Exploration-friendly**: Translates "how does memory work?" → MemoryEngine concepts
- **Fail-safe**: Returns original query on error, never crashes hook
- **User control**: `@raw` prefix disables enrichment

**3-Tier Enrichment**:
1. **Tier 1** (Always Relevant): Task ID, phase, current file, line, symbol, components
2. **Tier 2** (Query-Triggered): Pre-warmed patterns matching query type (bugs/implementation/testing/architecture)
3. **Tier 3** (Conversational State): Last topic for pronoun resolution ("fix it" → "fix validator.py")

**Size Limits**:
- MAX 500 chars total injection
- MAX 30% of original prompt length
- Strict prioritization (task/phase always kept, patterns truncated if needed)

**Integration Points**:
- **PostToolUse hook**: Warms file context after Read/Edit/Write
- **Orchestration task start**: Warms task context and component patterns
- **Orchestration phase change**: Re-warms patterns for new phase
- **UserPromptSubmit hook**: Fast context injection from cache

**Files**:
- `prism_mcp/bootstrap/index_documentation.py` - Documentation indexing bootstrap
- `prism_mcp/integrations/query_translator.py` - Query translation logic
- `prism_mcp/integrations/context_warmer.py` - Async Redis cache warming
- `prism_mcp/integrations/user_prompt_enricher.py` - Fast hook handler
- `prism_mcp/integrations/hook_integration.py` - Hook integration (updated)

**Bootstrap Usage**:
```bash
# Index all project documentation (run once)
python -m prism_mcp.bootstrap.index_documentation \
  --project-root /path/to/project \
  --project-id my_project \
  --include-global  # Also index ~/.claude/ docs

# Creates memories in ANCHORS tier for exploration queries
```

**Example Flow**:
```
1. Orchestration starts task "user-auth-refactor"
   → ContextWarmer.warm_task_context()
   → Pre-fetches patterns for auth components
   → Stores in Redis (1hr TTL)

2. User edits src/auth/validator.py
   → PostToolUse hook fires
   → ContextWarmer.warm_file_context()
   → Stores file context in Redis (10min TTL)

3. User types: "fix the validation error"
   → UserPromptSubmit hook fires
   → UserPromptEnricher.enrich() (<10ms)
   → Reads task, file, patterns from Redis
   → Injects:
       [TASK: user-auth-refactor]
       [PHASE: implementation]
       [FILE: validator.py:42]
       [PATTERN: Email regex must handle + in address]
```

### ADRManager (`prism_mcp/core/adr_manager.py`)

**Purpose**: Store and retrieve Architectural Decision Records in ANCHORS tier (never expires).

**Key Features**:
- Stores decisions with full context, alternatives considered, consequences
- Links ADRs to code symbols via Neo4j `DOCUMENTS` relationships
- Supports status updates (proposed → accepted → deprecated → superseded)
- Formatted as structured markdown documents

**When to Use**:
- After making significant architectural decisions
- When choosing between multiple approaches (document why alternatives were rejected)
- When establishing project patterns that should persist across sessions
- When documenting design rationale for future reference

**Core Methods**:
```python
# Store a decision
adr_id = adr_manager.store_adr(
    decision="Use FastAPI for HTTP API layer",
    context="Need web framework for REST API with async support",
    alternatives_considered=[
        {"alternative": "Flask", "reason_rejected": "No native async support"},
        {"alternative": "Django", "reason_rejected": "Too heavyweight for our needs"}
    ],
    consequences=[
        "Full async/await support for concurrent operations",
        "Automatic OpenAPI documentation generation",
        "Learning curve for team unfamiliar with FastAPI"
    ],
    status="accepted",  # proposed, accepted, deprecated, superseded
    session_id=session_id,
    project_id="prism_mcp",
    related_symbols=["HTTPAPIServer", "FastAPIApp"]
)

# Query decisions
adrs = adr_manager.query_adrs(
    query="API framework decisions",
    session_id=session_id,
    project_id="prism_mcp",
    status="accepted",  # Optional filter
    limit=10
)

# Update status (e.g., deprecate old decision)
adr_manager.update_adr_status(
    adr_id=adr_id,
    new_status="deprecated",
    session_id=session_id,
    reason="Replaced by decision ADR-2025-123"
)

# Link to code symbols
adr_manager.link_adr_to_code(
    adr_id=adr_id,
    symbol_ids=["FastAPIApp", "HTTPAPIServer"],
    session_id=session_id
)

# Get ADRs for specific code
adrs = adr_manager.get_adrs_for_symbol(
    symbol_id="FastAPIApp",
    session_id=session_id
)
```

**Storage Details**:
- Tier: ANCHORS (permanent)
- Type: `architecture_decision`
- Collection: `memories_e5` (semantic embeddings)
- Metadata: `adr_id`, `status`, `decision`, `timestamp`
- Graph: Links via `DOCUMENTS` relationships to code symbols

### DuplicationDetector (`prism_mcp/core/duplication_detector.py`)

**Purpose**: Find duplicate code patterns across projects using semantic embeddings (similarity threshold: 85%).

**Key Features**:
- AST-based code chunking (functions/classes/methods)
- Voyage code embeddings for semantic similarity
- Cosine similarity matrix computation
- Consolidation suggestions with estimated LOC reduction
- Multi-language support (currently Python only)

**When to Use**:
- Before refactoring to identify consolidation opportunities
- During code review to detect copy-paste duplication
- When analyzing technical debt
- Before implementing new features (avoid adding to duplication)

**Algorithm**:
1. Chunk code into blocks (functions, classes, methods via AST)
2. Generate Voyage embeddings for each block
3. Compute cosine similarity matrix
4. Cluster similar blocks (threshold: 0.85 = 85% similar)
5. Suggest extraction/consolidation strategies

**Core Methods**:
```python
# Detect duplicates across entire project
duplicates = detector.detect_project_duplicates(
    project_path="/path/to/project",
    min_lines=10,  # Ignore tiny blocks
    max_results=50,  # Top 50 duplicate groups
)

# Each result includes:
# - strategy: "extract_function"
# - suggested_name: "extracted_common_logic"
# - common_code: [list of common lines]
# - locations: [list of file paths and line ranges]
# - estimated_loc_reduction: number of lines saved

# Manual chunking and analysis
chunks = detector.chunk_code(
    file_path="src/module.py",
    content=file_content,
    language="python"
)

embeddings = detector.embed_chunks(chunks)
similarity_matrix = detector.compute_similarity_matrix(embeddings)
duplicates = detector.find_duplicates(chunks, similarity_matrix)

# Get consolidation suggestion
for dup_group in duplicates:
    suggestion = detector.suggest_consolidation(dup_group)
    print(f"Extract to: {suggestion['suggested_name']}")
    print(f"Save ~{suggestion['estimated_loc_reduction']} lines")
```

**Parameters**:
- `similarity_threshold`: 0.85 (85% similar, configurable 0.0-1.0)
- `min_lines`: 10 (ignore tiny blocks)
- `max_results`: 50 (top N duplicate groups)

**Limitations**:
- Currently Python-only (AST parsing)
- Skips tiny `__init__.py` files (<10 lines)
- Ignores trivial lines (imports, comments, braces)

## MCP Tools

### ADR Tools

**prism_store_adr**
```json
{
    "decision": "string (required)",
    "context": "string (required)",
    "alternatives_considered": [
        {
            "alternative": "string",
            "reason_rejected": "string"
        }
    ],
    "consequences": ["string"],
    "status": "string (required)",
    "session_id": "string (required)",
    "project_id": "string (optional)",
    "related_symbols": ["string (optional)"]
}
```

**prism_query_adrs**
```json
{
    "query": "string (required)",
    "session_id": "string (required)",
    "project_id": "string (optional)",
    "status": "string (optional)",
    "limit": "integer (default: 10)"
}
```

### Duplication Tool

**prism_detect_duplicates**
```json
{
    "project_path": "string (required)",
    "min_lines": "integer (default: 10)",
    "max_results": "integer (default: 50)",
    "similarity_threshold": "number (default: 0.85)"
}
```

## HTTP API Endpoints

### ADR Endpoints

**POST /api/adr/store**
- Store architectural decision record
- Body: Same as `prism_store_adr` tool
- Returns: `{"adr_id": "uuid"}`

**POST /api/adr/query**
- Query ADRs by search term
- Body: Same as `prism_query_adrs` tool
- Returns: `{"adrs": [...]}`

### Duplication Endpoint

**POST /api/duplication/detect**
- Detect code duplication across project
- Body: Same as `prism_detect_duplicates` tool
- Returns: `{"duplicates": [...], "summary": {...}}`
- Timeout: 600s (10 minutes for large projects)

## Usage Patterns

### Storing ADRs

**When**: After architecture decisions are made

```python
# Example: Store decision after choosing database
prism_store_adr(
    decision="Use Qdrant for vector storage",
    context="Need high-performance vector similarity search for embeddings",
    alternatives_considered=[
        {"alternative": "Pinecone", "reason_rejected": "Cloud-only, prefer self-hosted"},
        {"alternative": "Weaviate", "reason_rejected": "Heavier resource footprint"}
    ],
    consequences=[
        "Fast similarity search with HNSW algorithm",
        "Self-hosted deployment for data privacy",
        "Need to manage Qdrant infrastructure"
    ],
    status="accepted",
    session_id=current_session_id,
    project_id="prism_mcp",
    related_symbols=["QdrantManager", "VectorStore"]
)
```

### Querying ADRs

**When**: Before making related architectural changes

```python
# Example: Check existing database decisions
adrs = prism_query_adrs(
    query="database storage decisions",
    session_id=current_session_id,
    project_id="prism_mcp",
    status="accepted"  # Only show accepted decisions
)

# Review context and consequences before proceeding
for adr in adrs:
    print(f"Decision: {adr['metadata']['decision']}")
    print(f"Context: {adr['content']}")
```

### Detecting Duplicates

**When**: Before consolidation or refactoring work

```python
# Example: Find duplicates before refactoring
duplicates = prism_detect_duplicates(
    project_path="/home/user/repos/myproject",
    min_lines=15,  # Focus on substantial blocks
    max_results=20,  # Top 20 worst offenders
    similarity_threshold=0.90  # Very similar code (90%+)
)

# Analyze results
for dup in duplicates:
    print(f"Extract to: {dup['suggested_name']}")
    print(f"Locations: {len(dup['locations'])}")
    print(f"Savings: ~{dup['estimated_loc_reduction']} lines")

    # Show where duplicates exist
    for loc in dup['locations']:
        print(f"  {loc['file_path']}:{loc['line_start']}-{loc['line_end']}")
```

### Linking ADRs to Code

**When**: After implementing architectural decisions

```python
# Example: Link decision to implementation
prism_store_adr(
    decision="Implement 6-stage retrieval pipeline",
    context="Need sophisticated context retrieval beyond simple vector search",
    alternatives_considered=[
        {"alternative": "Simple vector search", "reason_rejected": "Insufficient context"},
        {"alternative": "BM25 only", "reason_rejected": "No semantic understanding"}
    ],
    consequences=[
        "Higher quality retrieval results",
        "More complex system to maintain",
        "Increased computational cost"
    ],
    status="accepted",
    session_id=session_id,
    project_id="prism_mcp",
    related_symbols=[
        "RetrievalCoordinator",
        "SemanticRetrieval",
        "GraphExpansion"
    ]
)

# Later: Find ADRs for specific code symbol
adrs = adr_manager.get_adrs_for_symbol(
    symbol_id="RetrievalCoordinator",
    session_id=session_id
)
# Returns all ADRs linked to this symbol
```

## Integration with PRISM Features

### ADRs in Memory Tiers

ADRs are stored in the **ANCHORS** tier alongside high-frustration corrections:
- Never expire (permanent architectural knowledge)
- Indexed with E5-Mistral-7B embeddings (semantic understanding)
- Linked to code symbols via Neo4j graph
- Retrievable through normal 6-stage retrieval pipeline

**Query Pattern**:
```python
# ADRs surface automatically in intelligent retrieval
results = prism_retrieve_memories(
    query="Why did we choose FastAPI?",
    session_id=session_id,
    tier="ANCHORS"  # Focus on architectural decisions
)
# Returns ADRs plus high-frustration corrections
```

### Duplication Detection in Workflow

Integrate duplication detection into development workflow:

1. **Pre-commit Hook**: Detect new duplicates
2. **Code Review**: Check for duplication in PR
3. **Refactoring Sprint**: Identify consolidation targets
4. **Technical Debt**: Track duplication over time

**Example Workflow**:
```bash
# Before starting feature work
duplicates=$(prism_detect_duplicates --project-path . --min-lines 20)
if [ "$duplicates" -gt 100 ]; then
    echo "High duplication detected, consider refactoring first"
fi

# During code review
prism_detect_duplicates --project-path ./src/new_feature --similarity-threshold 0.95
```

### Cross-Component Usage

**Architecture Planner → ADRManager**:
- Store decisions from architecture planning phase
- Link to skeleton code symbols

**Consolidation Analyzer → DuplicationDetector**:
- Find duplicate patterns before consolidation
- Prioritize by estimated LOC reduction

**Code Reviewer → ADRManager**:
- Verify implementation matches ADR decisions
- Flag deviations from documented approach

**Skeleton Builder → ADRManager**:
- Query related ADRs before creating skeleton
- Follow established patterns from decisions

## Critical Patterns

### UUID Systems
- **Legacy memories**: 12-char hex → integer via MD5
- **Preferences**: 36-char UUID → stored natively as string (NO conversion)
- **ADRs**: 36-char UUID → stored natively as string in metadata

### API Quirks
**Qdrant**:
```python
# WRONG
payload = record['payload']  # Record not subscriptable

# CORRECT
payload = record.payload  # Use dot notation

# Scroll returns tuple
results, next_offset = self.qdrant.client.scroll(...)
```

**Redis**:
```python
# Use raw client for list ops
self.redis.client.lpush(key, value)
preference_id = self.redis.client.lpop(key)
```

**Neo4j**:
```python
# No update_node_properties() - use Cypher
cypher = "MATCH (m:Memory {memory_id: $id}) SET m.status = $status"
neo4j.query(cypher, id=memory_id, status="approved")
```

### Retry Pattern for Eventual Consistency
```python
def _retrieve_with_retry(self, collection, ids, max_retries=10, delay=0.1):
    for attempt in range(max_retries):
        points = self.qdrant.client.retrieve(collection_name=collection, ids=ids)
        if points:
            return points
        if attempt < max_retries - 1:
            time.sleep(delay)
            delay *= 2  # Exponential backoff
    raise RuntimeError(f"Failed after {max_retries} attempts")
```

## Configuration

Edit `config/config.yaml` (NO env vars, NO defaults):

```yaml
database:
  neo4j_uri: "bolt://localhost:7687"
  neo4j_password: "prism_neo4j_2024"
  qdrant_url: "http://localhost:6333"
  redis_url: "redis://localhost:6379"

models:
  tier_strategy: "manual"
  manual_tier: 1  # 1=Full, 2=Dual, 3=Single, 4=CPU, 5=Keyword

intelligent_retrieval:
  semantic:
    min_similarity_threshold: 0.70
  graph:
    expansion_enabled: true
    max_depth: 2
  scoring:
    weights:
      semantic: 0.40
      graph: 0.30
      temporal: 0.20
      utility: 0.10
```

## Common Operations

### Start System
```bash
# Databases
nerdctl start prism-neo4j prism-qdrant prism-redis

# API server
python -m prism_mcp.interfaces.http_api --port 8090

# Load patterns (separate process, ~3 hours)
python -m prism_mcp.bootstrap.load_patterns_via_api \
  --api-url http://localhost:8090 \
  --api-key prism_development_key_2024
```

### Health Check
```bash
curl http://localhost:8090/api/health/detailed
```

## Recent Fixes (2025-09-29)

### Production Hardening Session

**Context**: Comprehensive code review of 4,988 lines across 5 core files identified 35 potential issues. 6 critical bugs fixed, 4 false alarms verified.

**Critical Fixes**:

1. **UUID Conversion Bug** (`qdrant_manager.py:487-515`)
   - Converting all IDs to integers via MD5, breaking preference retrieval (36-char UUIDs)
   - Fixed: Detect UUID format and pass through unchanged, only convert non-UUIDs to integers

2. **None Check Order** (`orchestrator.py:678-691`)
   - Accessing score attributes before checking if scores object exists
   - Fixed: Wrap score dict in parentheses so condition evaluates first

3. **Missing Confidence Validation** (`orchestrator.py:205-221`)
   - Pattern confidence accessed without checking key exists
   - Fixed: Explicit None check with descriptive ValueError (NO DEFAULTS)

4. **Session ID Non-Idempotency** (`orchestrator.py:504-540`)
   - Using timestamp for session ID (same inputs → different IDs)
   - Fixed: Created `_generate_session_id()` helper using code hash for deterministic fallback

5. **Rejection Learning Transaction Order** (`preference_manager.py:415-465`)
   - Recording rejection before learning (partial state on failure)
   - Fixed: Learn first, then update status only after success

6. **Graph Projection Error Handling** (`memory_engine.py:642-674`)
   - No fallback if GDS plugin unavailable
   - Fixed: Wrapped projection operations in try/except with graceful degradation

### Model Loading Device Fix (Earlier)

**Root cause**: When using `device_map="auto"`, model handles device placement internally. Attempting to verify with CPU tensors causes crash: "Expected all tensors on same device, got index on cpu, others on cuda:0"

**Fix**: Skip dimension verification when using `device_map`:
- `prism_mcp/models/quantization.py:223-227` (StarCoder2)
- `prism_mcp/models/quantization.py:275-279` (BGE-Reranker)

**Impact**: Unblocked entire pattern recognition system

## NO DEFAULTS Philosophy

- All config values must be explicit
- No `.get(key, default)` for required fields
- No try/except without re-raising
- System CRASHES if misconfigured

## Error Handling

All errors include specific solutions:
- `ConfigError`: Shows file, line, fix instructions
- `DatabaseConnectionError`: Service-specific troubleshooting
- `ModelLoadingError`: Memory, GPU, model-specific guidance

## Documentation

- **For users**: `README.md`, `SETUP_GPU.md`
- **For AI agents**: This file
- **For developers**: `docs/IMPLEMENTATION_NOTES.md`
- **Complete spec**: `docs/ULTIMATE_ARCHITECTURE_SPEC.md` (88K words)
- **Historical**: `docs/archive/*`