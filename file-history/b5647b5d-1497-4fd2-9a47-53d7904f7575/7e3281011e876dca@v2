"""
Simple synchronous HTTP client for PRISM.

Dead simple. No async. Just HTTP requests.
"""

import logging
from typing import Any, Optional

import requests


logger = logging.getLogger(__name__)


class PrismClient:
    """
    Simple sync HTTP client for PRISM.

    NO async, NO bridges, NO bullshit. Just HTTP.
    """

    def __init__(
        self,
        base_url: str = 'http://localhost:8090',
        api_key: Optional[str] = None,
    ):
        """
        Initialize PRISM client.

        Args:
            base_url: PRISM HTTP API URL
            api_key: API key for authentication
        """
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key or 'prism_development_key_2024'

        # Create session with headers
        self.session = requests.Session()
        self.session.headers.update(
            {
                'Authorization': f'Bearer {self.api_key}',
                'Content-Type': 'application/json',
            }
        )

        # Verify connection
        try:
            response = self.session.get(f'{self.base_url}/health', timeout=5)
            response.raise_for_status()
            logger.info(f'Connected to PRISM at {self.base_url}')
        except requests.exceptions.RequestException as e:
            logger.warning(f'Failed to connect to PRISM: {e}')

    def store_adr(
        self,
        decision: str,
        context: str,
        alternatives_considered: list[dict[str, str]],
        consequences: list[str],
        status: str,
        session_id: str,
        project_id: Optional[str] = None,
        related_symbols: Optional[list[str]] = None,
    ) -> dict[str, Any]:
        """
        Store an architectural decision record.

        Args:
            decision: The decision made
            context: Context/problem
            alternatives_considered: List of alternatives with rejection reasons
            consequences: List of consequences
            status: Decision status (proposed, accepted, deprecated, superseded)
            session_id: Current session ID
            project_id: Optional project identifier
            related_symbols: Optional list of related code symbols

        Returns:
            Response dict with adr_id

        Raises:
            requests.HTTPError: If request fails
        """
        payload = {
            'decision': decision,
            'context': context,
            'alternatives_considered': alternatives_considered,
            'consequences': consequences,
            'status': status,
            'session_id': session_id,
            'project_id': project_id,
            'related_symbols': related_symbols,
        }

        response = self.session.post(
            f'{self.base_url}/api/adr/store', json=payload, timeout=30
        )
        response.raise_for_status()
        return response.json()

    def query_adrs(
        self,
        query: str,
        session_id: str,
        project_id: Optional[str] = None,
        status: Optional[str] = None,
        limit: int = 10,
    ) -> dict[str, Any]:
        """
        Query ADRs by semantic search.

        Args:
            query: Search query
            session_id: Current session ID
            project_id: Optional project filter
            status: Optional status filter (accepted, proposed, etc.)
            limit: Maximum results

        Returns:
            Response dict with adrs list

        Raises:
            requests.HTTPError: If request fails
        """
        payload = {
            'query': query,
            'session_id': session_id,
            'project_id': project_id,
            'status': status,
            'limit': limit,
        }

        response = self.session.post(
            f'{self.base_url}/api/adr/query', json=payload, timeout=30
        )
        response.raise_for_status()
        return response.json()

    def detect_duplicates(
        self, project_path: str, min_lines: int = 10, max_results: int = 50
    ) -> dict[str, Any]:
        """
        Detect code duplication across project.

        Args:
            project_path: Path to project directory
            min_lines: Minimum lines to consider
            max_results: Maximum duplicate groups to return

        Returns:
            Response dict with duplicate_groups

        Raises:
            requests.HTTPError: If request fails
        """
        payload = {
            'project_path': project_path,
            'min_lines': min_lines,
            'max_results': max_results,
        }

        response = self.session.post(
            f'{self.base_url}/api/duplication/detect', json=payload, timeout=60
        )
        response.raise_for_status()
        return response.json()

    def check_health(self) -> bool:
        """
        Check if PRISM is healthy.

        Returns:
            True if healthy, False otherwise
        """
        try:
            response = self.session.get(f'{self.base_url}/health', timeout=5)
            return response.status_code == 200
        except requests.exceptions.RequestException:
            return False

    def close(self):
        """Close the session."""
        self.session.close()
