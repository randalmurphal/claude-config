"""
Architecture phase for defining system interfaces before implementation.

This phase:
1. Parses READY.md to extract components
2. Defines interfaces/contracts for each component
3. Generates dependency graph
4. Stores architecture decisions (ADRs) to PRISM
5. Creates skeleton structure with interface definitions
"""

from typing import Dict, List, Any, Optional
from pathlib import Path
import yaml
import logging
import re
import asyncio

logger = logging.getLogger(__name__)


class ArchitecturePhase:
    """
    Defines system architecture before implementation.

    Responsibilities:
    - Parse READY.md to extract components
    - Define interfaces/contracts for each component
    - Generate dependency graph
    - Store architecture decisions (ADRs) to PRISM
    - Create skeleton structure with interface definitions
    """

    def __init__(
        self,
        working_directory: str,
        task_id: str,
        prism_client=None,
        session_id: Optional[str] = None,
        project_id: Optional[str] = None,
    ):
        """
        Initialize architecture phase.

        Args:
            working_directory: Project root directory
            task_id: Orchestration task ID
            prism_client: Optional PRISM HTTP client for ADR storage
            session_id: Optional session ID for PRISM operations
            project_id: Optional project ID for PRISM operations
        """
        self.working_directory = Path(working_directory)
        self.task_id = task_id
        self.prism_client = prism_client
        self.session_id = session_id
        self.project_id = project_id
        self.architecture: Dict[str, Any] = {}

    def parse_ready_spec(self, spec_path: str) -> Dict[str, Any]:
        """
        Parse READY.md to extract component information.

        Args:
            spec_path: Path to READY.md file

        Returns:
            Dict with components, requirements, architecture
        """
        spec_file = Path(spec_path)
        if not spec_file.exists():
            raise FileNotFoundError(f'READY.md not found at {spec_path}')

        with open(spec_file, encoding='utf-8') as f:
            content = f.read()

        if not content.strip():
            raise ValueError(f'READY.md is empty at {spec_path}')

        sections = self._split_into_sections(content)

        components = self._extract_components_from_files(sections)

        requirements = []
        if 'Requirements (IMMUTABLE)' in sections:
            requirements = self._parse_list_items(
                sections['Requirements (IMMUTABLE)']
            )

        architecture_data = {
            'approach': sections.get('Proposed Approach (EVOLVABLE)', ''),
            'implementation_phases': self._parse_phases_section(
                sections.get('Implementation Phases', '')
            ),
            'quality_requirements': self._parse_quality_section(
                sections.get('Quality Requirements', '')
            ),
        }

        return {
            'components': components,
            'requirements': requirements,
            'architecture': architecture_data,
        }

    def query_past_architectures(
        self, query: str, limit: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Query PRISM for similar past architectures.

        Retrieves ADRs from past projects that might inform current
        architectural decisions.

        Args:
            query: Search query (e.g., "authentication system", "payment processing")
            limit: Maximum results to return

        Returns:
            List of relevant ADRs from past projects
        """
        if not self.prism_client or not self.session_id:
            logger.debug(
                'PRISM client or session_id not available - skipping past architecture query'
            )
            return []

        try:
            logger.info(f'Querying PRISM for past architectures: "{query}"')

            result = asyncio.run(
                self.prism_client.query_adrs(
                    query=query,
                    session_id=self.session_id,
                    project_id=None,  # Query across all projects
                    status='accepted',  # Only accepted decisions
                    limit=limit,
                )
            )

            adrs = result.get('adrs', [])
            logger.info(
                f'Found {len(adrs)} relevant ADRs from past architectures'
            )

            return adrs

        except Exception as e:
            logger.warning(f'Failed to query past architectures from PRISM: {e}')
            return []

    def define_interfaces(self, components: List[str]) -> Dict[str, Any]:
        """
        Define interfaces/contracts for each component.

        Args:
            components: List of component names

        Returns:
            Dict mapping component name to interface definition
        """
        interfaces = {}

        for component in components:
            component_name = self._normalize_component_name(component)

            interfaces[component_name] = {
                'name': component_name,
                'public_methods': self._infer_public_methods(component_name),
                'data_structures': self._infer_data_structures(component_name),
                'error_types': self._infer_error_types(component_name),
                'dependencies': [],
            }

        logger.info(f'Defined interfaces for {len(interfaces)} components')
        return interfaces

    def extract_dependencies(
        self, components: Dict[str, Any]
    ) -> Dict[str, List[str]]:
        """
        Extract dependencies between components.

        Args:
            components: Component definitions with interfaces

        Returns:
            Dict mapping component name to list of dependencies
        """
        dependencies: Dict[str, List[str]] = {}

        for component_name, interface in components.items():
            component_deps = []

            for method in interface.get('public_methods', []):
                method_name = method.get('name', '')
                params = method.get('parameters', [])
                return_type = method.get('return_type', '')

                for param in params:
                    param_type = param.get('type', '')
                    dep = self._extract_dependency_from_type(
                        param_type, components
                    )
                    if dep and dep != component_name:
                        component_deps.append(dep)

                dep = self._extract_dependency_from_type(
                    return_type, components
                )
                if dep and dep != component_name:
                    component_deps.append(dep)

            for data_struct in interface.get('data_structures', []):
                for field in data_struct.get('fields', []):
                    field_type = field.get('type', '')
                    dep = self._extract_dependency_from_type(
                        field_type, components
                    )
                    if dep and dep != component_name:
                        component_deps.append(dep)

            dependencies[component_name] = list(set(component_deps))

        logger.info(
            f'Extracted dependencies for {len(dependencies)} components'
        )
        return dependencies

    def store_adrs(self, decisions: List[Dict[str, Any]]) -> None:
        """
        Store architectural decision records to PRISM.

        ADRs are stored in PRISM's ANCHORS tier (never expires) for
        permanent reference across sessions.

        Args:
            decisions: List of ADRs to store. Each decision should have:
                - context: Problem/situation being addressed
                - decision: The decision made
                - alternatives: List of alternatives considered (optional)
                - consequences: List of consequences (optional)
                - title: Decision title (optional, used for logging)
                - status: Status (optional, defaults to 'accepted')
        """
        if not decisions:
            logger.info('Storing 0 architectural decisions to PRISM')
            return

        logger.info(f'Storing {len(decisions)} architectural decisions to PRISM')

        # If no PRISM client, just log (for backward compatibility)
        if not self.prism_client:
            logger.warning(
                'PRISM client not available - ADRs will be logged but not stored'
            )
            for decision in decisions:
                logger.info(f'ADR (not stored): {decision.get("title", decision.get("decision", "Untitled"))}')
            return

        # If no session_id, we can't store to PRISM
        if not self.session_id:
            logger.warning(
                'No session_id provided - ADRs will be logged but not stored to PRISM'
            )
            for decision in decisions:
                logger.info(f'ADR (no session): {decision.get("title", decision.get("decision", "Untitled"))}')
            return

        # Store each ADR to PRISM
        for decision in decisions:
            try:
                context = decision.get('context', '')
                chosen = decision.get('decision', '')
                alternatives = decision.get('alternatives', [])
                consequences = decision.get('consequences', [])
                status = decision.get('status', 'accepted')
                title = decision.get('title', chosen[:50] if chosen else 'Untitled')

                # Ensure alternatives is in correct format
                if isinstance(alternatives, list) and alternatives:
                    # If it's a list of strings, convert to dict format
                    if isinstance(alternatives[0], str):
                        alternatives = [
                            {'alternative': alt, 'reason_rejected': 'Not selected'}
                            for alt in alternatives
                        ]

                # Ensure consequences is a list
                if isinstance(consequences, str):
                    consequences = [consequences]

                # Call PRISM via HTTP client (async)
                asyncio.run(
                    self.prism_client.store_adr(
                        decision=chosen,
                        context=context,
                        alternatives_considered=alternatives,
                        consequences=consequences,
                        status=status,
                        session_id=self.session_id,
                        project_id=self.project_id,
                        related_symbols=decision.get('related_symbols', []),
                    )
                )

                logger.info(f'ADR stored to PRISM: {title}')

            except Exception as e:
                # Don't fail the architecture phase if ADR storage fails
                logger.error(
                    f'Failed to store ADR "{decision.get("title", "unknown")}" to PRISM: {e}'
                )
                logger.debug('ADR content:', exc_info=True)

    def generate_architecture_yaml(
        self, interfaces: Dict[str, Any], dependencies: Dict[str, List[str]]
    ) -> None:
        """
        Generate architecture.yaml with all interfaces and dependencies.

        Args:
            interfaces: Component interface definitions
            dependencies: Component dependency graph
        """
        architecture = {
            'version': '1.0',
            'task_id': self.task_id,
            'components': interfaces,
            'dependencies': dependencies,
        }

        output_path = self.working_directory / 'architecture.yaml'
        with open(output_path, 'w') as f:
            yaml.dump(architecture, f, default_flow_style=False)

        logger.info(f'Generated architecture.yaml at {output_path}')
        self.architecture = architecture

    def validate_architecture(self) -> bool:
        """
        Validate architecture for completeness and correctness.

        Returns:
            True if architecture is valid, False otherwise
        """
        if not self.architecture:
            logger.error('Architecture is empty')
            return False

        components = self.architecture.get('components', {})
        if not components:
            logger.error('No components defined in architecture')
            return False

        for component_name, interface in components.items():
            if not interface.get('public_methods'):
                logger.warning(
                    f'Component {component_name} has no public methods defined'
                )

        dependencies = self.architecture.get('dependencies', {})

        try:
            from orchestration_mcp.services.dependency_manager import (
                DependencyManager,
            )

            dep_manager = DependencyManager(
                neo4j_uri='bolt://localhost:7687',
                neo4j_user='neo4j',
                neo4j_password='password',
            )
            try:
                dep_manager.store_dependency_graph(self.task_id, dependencies)
                has_cycles = dep_manager.has_circular_dependencies(self.task_id)

                dep_manager.clear_task_graph(self.task_id)
                dep_manager.close()

                if has_cycles:
                    logger.error(
                        'Circular dependencies detected in architecture'
                    )
                    return False
            except Exception as e:
                logger.warning(f'Could not check circular dependencies: {e}')
        except ImportError:
            logger.warning('DependencyManager not available for validation')

        for component_name, deps in dependencies.items():
            for dep in deps:
                if dep not in components:
                    logger.error(
                        f'Component {component_name} depends on unknown component {dep}'
                    )
                    return False

        logger.info('Architecture validation passed')
        return True

    def execute(self, ready_spec_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute architecture phase.

        Args:
            ready_spec_path: Optional path to READY.md file

        Returns:
            Dict with architecture details and status
        """
        if ready_spec_path:
            spec_data = self.parse_ready_spec(ready_spec_path)
            components = spec_data.get('components', [])
        else:
            components = self._discover_components()

        interfaces = self.define_interfaces(components)
        dependencies = self.extract_dependencies(interfaces)

        self.generate_architecture_yaml(interfaces, dependencies)

        if not self.validate_architecture():
            raise ValueError('Architecture validation failed')

        return {
            'status': 'completed',
            'components': len(interfaces),
            'dependencies': dependencies,
            'architecture_file': str(
                self.working_directory / 'architecture.yaml'
            ),
        }

    def _discover_components(self) -> List[str]:
        """
        Discover components from existing codebase.

        Returns:
            List of component names
        """
        components = []

        if not self.working_directory.exists():
            logger.warning(
                f'Working directory does not exist: {self.working_directory}'
            )
            return components

        skip_dirs = {
            '__pycache__',
            '.git',
            '.pytest_cache',
            '.mypy_cache',
            'node_modules',
            'venv',
            '.venv',
            'env',
        }

        for py_file in self.working_directory.rglob('*.py'):
            if any(skip_dir in py_file.parts for skip_dir in skip_dirs):
                continue

            if py_file.stem.startswith('test_'):
                continue

            if py_file.stem == '__init__':
                continue

            relative_path = py_file.relative_to(self.working_directory)
            module_name = str(relative_path.with_suffix('')).replace('/', '.')

            components.append(module_name)

        logger.info(f'Discovered {len(components)} components from codebase')
        return components

    def _split_into_sections(self, content: str) -> Dict[str, str]:
        """Split markdown content into sections by ## headers."""
        sections = {}
        current_section = None
        current_content = []

        for line in content.split('\n'):
            header_match = re.match(r'^##\s+(.+)$', line)
            if header_match:
                if current_section:
                    sections[current_section] = '\n'.join(
                        current_content
                    ).strip()

                current_section = header_match.group(1).strip()
                current_content = []
            elif current_section:
                current_content.append(line)

        if current_section:
            sections[current_section] = '\n'.join(current_content).strip()

        return sections

    def _extract_components_from_files(
        self, sections: Dict[str, str]
    ) -> List[str]:
        """Extract component list from Files to Create/Modify section."""
        components = []

        files_section = sections.get('Files to Create/Modify', '')
        if not files_section:
            return components

        for line in files_section.split('\n'):
            line = line.strip()
            if re.match(r'^[-*+]\s+', line) and not re.match(
                r'^\s+[-*+]', line
            ):
                file_path = re.sub(r'^[-*+]\s+', '', line).strip()

                if file_path.endswith('.py'):
                    component_name = (
                        Path(file_path)
                        .with_suffix('')
                        .as_posix()
                        .replace('/', '.')
                    )
                    components.append(component_name)

        return components

    def _parse_list_items(self, content: str) -> List[str]:
        """Parse bullet point or numbered list from content."""
        items = []
        for line in content.split('\n'):
            line = line.strip()
            if re.match(r'^[-*+]\s+', line) or re.match(r'^\d+\.\s+', line):
                item = re.sub(r'^[-*+]\s+', '', line)
                item = re.sub(r'^\d+\.\s+', '', item)
                items.append(item.strip())
        return items

    def _parse_phases_section(self, content: str) -> List[Dict[str, str]]:
        """Parse implementation phases from section."""
        phases = []
        lines = content.split('\n')
        current_phase = None

        for line in lines:
            phase_match = re.match(
                r'^###\s+Phase\s+(\d+):\s+(.+)$', line, re.IGNORECASE
            )
            if phase_match:
                if current_phase:
                    phases.append(current_phase)

                current_phase = {
                    'number': int(phase_match.group(1)),
                    'name': phase_match.group(2).strip(),
                    'description': '',
                }
            elif current_phase and line.strip():
                current_phase['description'] += ' ' + line.strip()

        if current_phase:
            phases.append(current_phase)

        return phases

    def _parse_quality_section(self, content: str) -> Dict[str, str]:
        """Parse quality requirements section."""
        requirements = {}
        for line in content.split('\n'):
            line = line.strip()
            match = re.match(r'^[-*+]\s*([^:]+):\s*(.+)$', line)
            if match:
                category = match.group(1).strip().lower()
                requirement = match.group(2).strip()
                requirements[category] = requirement
        return requirements

    def _normalize_component_name(self, component: str) -> str:
        """Normalize component name to valid identifier."""
        normalized = component.replace('/', '_').replace('.', '_')
        normalized = re.sub(r'[^a-zA-Z0-9_]', '', normalized)
        return normalized

    def _infer_public_methods(
        self, component_name: str
    ) -> List[Dict[str, Any]]:
        """Infer public methods for a component based on name."""
        methods = []

        if 'service' in component_name.lower():
            methods.append(
                {
                    'name': 'process',
                    'parameters': [{'name': 'data', 'type': 'Dict[str, Any]'}],
                    'return_type': 'Dict[str, Any]',
                    'description': 'Process data through service',
                }
            )

        if 'manager' in component_name.lower():
            methods.append(
                {
                    'name': 'create',
                    'parameters': [{'name': 'entity', 'type': 'Any'}],
                    'return_type': 'str',
                    'description': 'Create a new entity',
                }
            )
            methods.append(
                {
                    'name': 'get',
                    'parameters': [{'name': 'id', 'type': 'str'}],
                    'return_type': 'Optional[Any]',
                    'description': 'Get entity by ID',
                }
            )

        if (
            'repository' in component_name.lower()
            or 'repo' in component_name.lower()
        ):
            methods.append(
                {
                    'name': 'save',
                    'parameters': [{'name': 'entity', 'type': 'Any'}],
                    'return_type': 'None',
                    'description': 'Save entity to storage',
                }
            )
            methods.append(
                {
                    'name': 'find',
                    'parameters': [{'name': 'id', 'type': 'str'}],
                    'return_type': 'Optional[Any]',
                    'description': 'Find entity by ID',
                }
            )

        if not methods:
            methods.append(
                {
                    'name': 'execute',
                    'parameters': [],
                    'return_type': 'None',
                    'description': 'Execute component logic',
                }
            )

        return methods

    def _infer_data_structures(
        self, component_name: str
    ) -> List[Dict[str, Any]]:
        """Infer data structures for a component."""
        structures = []

        entity_name = component_name.replace('_service', '').replace(
            '_manager', ''
        )
        entity_name = entity_name.replace('_repository', '').replace(
            '_repo', ''
        )

        if entity_name:
            structures.append(
                {
                    'name': f'{entity_name.capitalize()}Data',
                    'fields': [
                        {'name': 'id', 'type': 'str'},
                        {'name': 'created_at', 'type': 'datetime'},
                    ],
                }
            )

        return structures

    def _infer_error_types(self, component_name: str) -> List[str]:
        """Infer error types for a component."""
        errors = ['ValidationError']

        if (
            'repository' in component_name.lower()
            or 'repo' in component_name.lower()
        ):
            errors.append('NotFoundError')
            errors.append('StorageError')

        if 'service' in component_name.lower():
            errors.append('ProcessingError')

        if 'manager' in component_name.lower():
            errors.append('ManagerError')

        return errors

    def _extract_dependency_from_type(
        self, type_str: str, components: Dict[str, Any]
    ) -> Optional[str]:
        """Extract component dependency from type string."""
        for component_name in components.keys():
            if component_name in type_str:
                return component_name

        return None
