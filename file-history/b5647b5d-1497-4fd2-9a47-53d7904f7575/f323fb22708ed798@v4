#!/usr/bin/env python3
"""PRISM HTTP Client for Orchestration MCP.

Provides full integration with PRISM's HTTP API for semantic reasoning,
memory storage/retrieval, and hallucination detection.
"""

import asyncio
import logging
from typing import Any

import aiohttp

logger = logging.getLogger(__name__)


class PRISMHTTPClient:
    """Async HTTP client for PRISM MCP server."""

    def __init__(self, base_url: str = None, api_key: str = None):
        """Initialize PRISM HTTP client.

        Args:
            base_url: Base URL for PRISM HTTP server. Defaults to http://localhost:8090
            api_key: API key for authentication. Defaults to development key
        """
        self.base_url = base_url or "http://localhost:8090"
        self.api_key = api_key or "prism_development_key_2024"
        self.session = None
        self._connected = False

    async def __aenter__(self):
        """Async context manager entry."""
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def connect(self):
        """Initialize session and verify connection."""
        if self.session:
            return

        # Create session with authentication header
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
        }
        self.session = aiohttp.ClientSession(headers=headers)
        self._connected = await self.check_health()

        if self._connected:
            logger.info(f"Connected to PRISM HTTP server at {self.base_url}")
        else:
            logger.warning(
                f"PRISM HTTP server not available at {self.base_url}"
            )

    async def close(self):
        """Close the session."""
        if self.session:
            await self.session.close()
            self.session = None
            self._connected = False

    async def check_health(self) -> bool:
        """Check if PRISM server is available.

        Returns:
            True if server is healthy, False otherwise
        """
        try:
            if not self.session:
                return False

            async with self.session.get(
                f"{self.base_url}/health", timeout=5
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    services = data.get("services", {})
                    all_healthy = all(services.values())
                    if not all_healthy:
                        unhealthy = [k for k, v in services.items() if not v]
                        logger.warning(
                            f"Some PRISM services unhealthy: {unhealthy}"
                        )
                    return True
                logger.error(
                    f"PRISM health check failed with status {response.status}"
                )
                return False
        except asyncio.TimeoutError:
            logger.error("PRISM health check timed out")
            return False
        except Exception as e:
            logger.error(f"PRISM health check error: {e}")
            return False

    @property
    def is_connected(self) -> bool:
        """Check if client is connected to PRISM."""
        return self._connected

    async def analyze(self, text: str) -> dict[str, Any]:
        """Comprehensive PRISM analysis of text.

        Args:
            text: Text to analyze

        Returns:
            Analysis results including confidence, zone, reasoning

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If analysis fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        try:
            async with self.session.post(
                f"{self.base_url}/analyze", json={"text": text}, timeout=30
            ) as response:
                if response.status == 200:
                    return await response.json()
                if response.status == 503:
                    raise RuntimeError("PRISM reasoning service unavailable")
                error_text = await response.text()
                raise RuntimeError(
                    f"Analysis failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("PRISM analysis timed out after 30 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during analysis: {e}")

    async def semantic_residue(
        self, input_text: str, ground_truth: str
    ) -> dict[str, Any]:
        """Calculate semantic drift between texts.

        Args:
            input_text: Input text
            ground_truth: Ground truth text

        Returns:
            Semantic residue analysis with drift score and confidence

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If calculation fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        try:
            async with self.session.post(
                f"{self.base_url}/semantic_residue",
                json={"input_text": input_text, "ground_truth": ground_truth},
                timeout=20,
            ) as response:
                if response.status == 200:
                    return await response.json()
                if response.status == 503:
                    raise RuntimeError("PRISM reasoning service unavailable")
                error_text = await response.text()
                raise RuntimeError(
                    f"Semantic residue calculation failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError(
                "Semantic residue calculation timed out after 20 seconds"
            )
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during semantic residue: {e}")

    async def detect_hallucination(
        self, text: str, confidence_threshold: float = 0.8
    ) -> dict[str, Any]:
        """Detect hallucination risk in text.

        Args:
            text: Text to check
            confidence_threshold: Confidence threshold (0-1)

        Returns:
            Hallucination detection results

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If detection fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        try:
            async with self.session.post(
                f"{self.base_url}/detect_hallucination",
                json={
                    "text": text,
                    "confidence_threshold": confidence_threshold,
                },
                timeout=20,
            ) as response:
                if response.status == 200:
                    return await response.json()
                if response.status == 503:
                    raise RuntimeError("PRISM verification service unavailable")
                error_text = await response.text()
                raise RuntimeError(
                    f"Hallucination detection failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError(
                "Hallucination detection timed out after 20 seconds"
            )
        except aiohttp.ClientError as e:
            raise RuntimeError(
                f"Network error during hallucination detection: {e}"
            )

    async def store_memory(
        self, content: str, tier: str, metadata: dict | None = None
    ) -> dict[str, Any]:
        """Store content in PRISM memory.

        Args:
            content: Content to store
            tier: Memory tier (ANCHORS, WORKING, LONGTERM, EPISODIC)
            metadata: Optional metadata

        Returns:
            Storage result with memory key

        Raises:
            ConnectionError: If PRISM is not available
            ValueError: If tier is invalid
            RuntimeError: If storage fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        valid_tiers = ["ANCHORS", "WORKING", "LONGTERM", "EPISODIC"]
        if tier not in valid_tiers:
            raise ValueError(
                f"Invalid tier '{tier}'. Must be one of {valid_tiers}"
            )

        try:
            async with self.session.post(
                f"{self.base_url}/store_memory",
                json={
                    "content": content,
                    "tier": tier,
                    "metadata": metadata or {},
                },
                timeout=10,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    if result.get("success"):
                        logger.info(
                            f'Stored memory in {tier}: {result.get("key")}'
                        )
                    else:
                        logger.warning(
                            f'Memory storage reported failure: {result.get("message")}'
                        )
                    return result
                if response.status == 503:
                    raise RuntimeError("PRISM memory service unavailable")
                error_text = await response.text()
                raise RuntimeError(
                    f"Memory storage failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Memory storage timed out after 10 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during memory storage: {e}")

    async def search_memory(
        self, query: str, tier: str | None = None, limit: int = 10
    ) -> dict[str, Any]:
        """Search PRISM memory.

        Args:
            query: Search query
            tier: Optional specific tier to search
            limit: Maximum results

        Returns:
            Search results with relevance scores

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If search fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        try:
            request_data = {"query": query, "limit": limit}
            if tier:
                request_data["tier"] = tier

            async with self.session.post(
                f"{self.base_url}/search_memory", json=request_data, timeout=15
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.debug(
                        f'Found {result.get("total_found", 0)} memories for query: {query}'
                    )
                    return result
                if response.status == 503:
                    raise RuntimeError("PRISM memory service unavailable")
                error_text = await response.text()
                raise RuntimeError(
                    f"Memory search failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Memory search timed out after 15 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during memory search: {e}")

    async def query_context(
        self, query: str, project_id: str, max_symbols: int = 20
    ) -> dict[str, Any]:
        """Query relevant code context for a query.

        Args:
            query: Search query (e.g., "authentication functions")
            project_id: Project identifier
            max_symbols: Maximum symbols to return

        Returns:
            {
                "symbols": [
                    {
                        "name": "login",
                        "type": "function",
                        "file": "src/auth.py",
                        "lines": "45-67",
                        "signature": "def login(username, password)",
                        "docstring": "Authenticates user"
                    }
                ],
                "patterns": [],
                "related_files": ["src/auth.py", ...]
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If query or project_id missing, or query fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        if not query:
            raise RuntimeError("query required")
        if not project_id:
            raise RuntimeError("project_id required")

        try:
            request_data = {
                "query": query,
                "project_id": project_id,
                "max_symbols": max_symbols,
            }

            async with self.session.post(
                f"{self.base_url}/api/query_context",
                json=request_data,
                timeout=30,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.debug(
                        f'Found {len(result.get("symbols", []))} symbols for query: {query}'
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Context query failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Context query timed out after 30 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during context query: {e}")

    async def filter_by_relevance(
        self,
        items: list[Any],
        query: str,
        content_extractor=None,
        top_k: int = 5,
    ) -> list[tuple]:
        """Filter items by semantic relevance using PRISM.

        Args:
            items: Items to filter
            query: Semantic query for relevance
            content_extractor: Function to extract text from items
            top_k: Number of top results to return

        Returns:
            List of (item, relevance_score) tuples sorted by relevance

        Raises:
            RuntimeError: If filtering fails
        """
        if not self._connected:
            logger.warning(
                "PRISM not connected, returning first items without filtering"
            )
            return [(item, 1.0) for item in items[:top_k]]

        if not items:
            return []

        # Default content extractor
        if content_extractor is None:
            content_extractor = lambda x: str(x)

        relevance_scores = []

        for item in items:
            try:
                content = content_extractor(item)
                # Calculate semantic similarity
                result = await self.semantic_residue(content, query)
                # Convert residue (drift) to relevance (similarity)
                relevance = 1.0 - result.get("drift_score", 0.5)
                relevance_scores.append((item, relevance))
            except Exception as e:
                logger.warning(f"Failed to calculate relevance for item: {e}")
                # Default to low relevance on error
                relevance_scores.append((item, 0.1))

        # Sort by relevance (highest first)
        relevance_scores.sort(key=lambda x: x[1], reverse=True)

        return relevance_scores[:top_k]

    async def validate_output(
        self, output: str, expected: str, confidence_threshold: float = 0.7
    ) -> dict[str, Any]:
        """Validate output against expected using PRISM.

        Args:
            output: Actual output
            expected: Expected output
            confidence_threshold: Minimum confidence required

        Returns:
            Validation result with pass/fail and details

        Raises:
            RuntimeError: If validation fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )

        try:
            # Check semantic drift
            residue_result = await self.semantic_residue(output, expected)
            drift_score = residue_result.get("drift_score", 1.0)

            # Check for hallucination
            hall_result = await self.detect_hallucination(
                output, confidence_threshold
            )
            risk_score = hall_result.get("risk_score", 0.5)

            # Combined validation
            confidence = residue_result.get("confidence", 0.0)
            passed = (
                drift_score < 0.3
                and risk_score < 0.3
                and confidence >= confidence_threshold
            )

            return {
                "passed": passed,
                "confidence": confidence,
                "drift_score": drift_score,
                "hallucination_risk": risk_score,
                "zone": residue_result.get("zone", "unknown"),
                "risk_factors": hall_result.get("risk_factors", []),
                "recommendation": hall_result.get("recommendation", ""),
                "details": {
                    "semantic_match": 1.0 - drift_score,
                    "confidence_met": confidence >= confidence_threshold,
                    "low_hallucination": risk_score < 0.3,
                },
            }
        except Exception as e:
            logger.error(f"Validation failed: {e}")
            raise RuntimeError(f"PRISM validation failed: {e}")

    async def retrieve_memories(
        self,
        query: str,
        session_id: str,
        role: str | None = None,
        task_type: str | None = None,
        task_id: str | None = None,
        phase: str | None = None,
        project_id: str | None = None,
        branch: str | None = None,
        git_sha: str | None = None,
        limit: int = 10,
        tier: str | None = None,
        exclude_memory_ids: list[str] | None = None,
        return_scores: bool = False,
    ) -> dict[str, Any]:
        """Intelligent memory retrieval with 6-stage pipeline.

        Uses PRISM's full retrieval pipeline:
        1. Semantic search (Qdrant)
        2. Graph expansion (Neo4j PageRank + BFS)
        3. Context filtering (role/task/phase compatibility)
        4. Temporal ranking (git SHA boost + age decay)
        5. Diversity selection (MMR + Louvain communities)
        6. Utility scoring (learned from feedback)

        Args:
            query: Search query
            session_id: Session ID for deduplication (REQUIRED)
            role: Role context (architect, implementer, reviewer, debugger)
            task_type: Task type (skeleton, implementation, testing)
            task_id: Specific task identifier
            phase: Phase (prepare, execute, validate)
            project_id: Filter by project
            branch: Filter by branch
            git_sha: Current git SHA for recency boost
            limit: Maximum results (default 10)
            tier: Filter by tier (ANCHORS, LONGTERM, EPISODIC, WORKING)
            exclude_memory_ids: Memory IDs to exclude
            return_scores: Return detailed scores for debugging

        Returns:
            {
                "memories": [...],
                "retrieval_id": "uuid",
                "total_candidates": N,
                "scores": {...} (if return_scores=True)
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If query or session_id missing, or retrieval fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not query:
            raise RuntimeError("query is required for retrieve_memories")
        if not session_id:
            raise RuntimeError("session_id is required for retrieve_memories")

        try:
            request_data = {
                "query": query,
                "session_id": session_id,
                "limit": limit,
                "return_scores": return_scores,
            }

            if role:
                request_data["role"] = role
            if task_type:
                request_data["task_type"] = task_type
            if task_id:
                request_data["task_id"] = task_id
            if phase:
                request_data["phase"] = phase
            if project_id:
                request_data["project_id"] = project_id
            if branch:
                request_data["branch"] = branch
            if git_sha:
                request_data["git_sha"] = git_sha
            if tier:
                request_data["tier"] = tier
            if exclude_memory_ids:
                request_data["exclude_memory_ids"] = exclude_memory_ids

            async with self.session.post(
                f"{self.base_url}/api/retrieve_memories",
                json=request_data,
                timeout=30,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.debug(
                        f'Retrieved {len(result.get("memories", []))} memories '
                        f"for query '{query[:50]}...'"
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Memory retrieval failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Memory retrieval timed out after 30 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during memory retrieval: {e}")

    async def record_memory_feedback(
        self,
        retrieval_id: str,
        memory_id: str,
        used: bool,
        helpful: bool | None = None,
        reason: str | None = None,
    ) -> dict[str, Any]:
        """Record feedback about memory utility for learning loop.

        This enables PRISM's utility tracker to learn which memories
        are actually useful in different contexts.

        Args:
            retrieval_id: UUID from retrieve_memories() call
            memory_id: Memory that was retrieved
            used: Whether the memory was actually used
            helpful: Optional explicit helpfulness rating (defaults to used)
            reason: Optional explanation for feedback

        Returns:
            {"success": True, "message": "..."}

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If retrieval_id or memory_id missing, or recording fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not retrieval_id:
            raise RuntimeError(
                "retrieval_id is required for record_memory_feedback"
            )
        if not memory_id:
            raise RuntimeError(
                "memory_id is required for record_memory_feedback"
            )

        try:
            request_data = {
                "retrieval_id": retrieval_id,
                "memory_id": memory_id,
                "used": used,
            }

            if helpful is not None:
                request_data["helpful"] = helpful
            if reason:
                request_data["reason"] = reason

            async with self.session.post(
                f"{self.base_url}/api/record_feedback",
                json=request_data,
                timeout=10,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.debug(
                        f"Recorded feedback for memory {memory_id}: "
                        f"used={used}, helpful={helpful}"
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Feedback recording failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Feedback recording timed out after 10 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during feedback recording: {e}")

    async def detect_patterns(
        self, code: str, language: str, instruction: str | None = None
    ) -> dict[str, Any]:
        """Detect code patterns using PRISM's pattern engine.

        Uses hybrid AST + semantic detection for pattern matching.

        Args:
            code: Code to analyze
            language: Programming language (python, go, javascript, typescript)
            instruction: Optional instruction context for drift detection

        Returns:
            {
                "patterns": [...],
                "drift_score": float,
                "suggestions": [...],
                "confidence": {...}
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If code or language missing, or detection fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not code:
            raise RuntimeError("code is required for detect_patterns")
        if not language:
            raise RuntimeError("language is required for detect_patterns")

        try:
            request_data = {"code": code, "language": language}

            if instruction:
                request_data["instruction"] = instruction

            async with self.session.post(
                f"{self.base_url}/api/detect_patterns",
                json=request_data,
                timeout=20,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.debug(
                        f'Detected {len(result.get("patterns", []))} patterns '
                        f'in {language} code'
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Pattern detection failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Pattern detection timed out after 20 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during pattern detection: {e}")

    async def end_session(self, session_id: str) -> dict[str, Any]:
        """End session and promote valuable memories.

        PRISM promotes WORKING memories to EPISODIC based on:
        - access_count >= 2
        - frustration_score > 0.3

        Args:
            session_id: Session identifier

        Returns:
            {
                "promoted_count": N,
                "removed_count": M
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If session_id missing or operation fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not session_id:
            raise RuntimeError("session_id is required for end_session")

        try:
            async with self.session.post(
                f"{self.base_url}/api/end_session",
                json={"session_id": session_id},
                timeout=15,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.info(
                        f'Ended session {session_id}: '
                        f'promoted {result.get("promoted_count", 0)} memories'
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"End session failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("End session timed out after 15 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during end session: {e}")

    async def get_index_state(
        self, project_id: str
    ) -> dict[str, Any] | None:
        """Get indexing state for a project.

        Args:
            project_id: Project identifier

        Returns:
            Index state dict or None if not indexed

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If project_id missing or query fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not project_id:
            raise RuntimeError("project_id is required for get_index_state")

        try:
            async with self.session.get(
                f"{self.base_url}/api/index_state",
                params={"project_id": project_id},
                timeout=10,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    return result if result else None
                if response.status == 404:
                    return None
                error_text = await response.text()
                raise RuntimeError(
                    f"Get index state failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Get index state timed out after 10 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during get index state: {e}")

    async def list_preferences(
        self,
        session_id: str,
        status: str | None = None,
        category: str | None = None,
        project_id: str | None = None,
        limit: int = 50,
    ) -> dict[str, Any]:
        """List user preferences for a project.

        Phase 5: Orchestration Integration
        Used to load approved preferences at prepare_phase.

        Args:
            session_id: Session ID
            status: Filter by status (pending, approved, rejected)
            category: Filter by category (style, pattern, tool, quality)
            project_id: Filter by project
            limit: Maximum preferences to return

        Returns:
            {
                "preferences": [
                    {
                        "preference_id": str,
                        "content": str,
                        "category": str,
                        "status": str,
                        "confidence": float,
                        "code_examples": [...]
                    }
                ]
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If session_id missing or request fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not session_id:
            raise RuntimeError("session_id is required for list_preferences")

        try:
            request_data = {
                "session_id": session_id,
                "limit": limit,
            }

            if status:
                request_data["status"] = status
            if category:
                request_data["category"] = category
            if project_id:
                request_data["project_id"] = project_id

            async with self.session.post(
                f"{self.base_url}/api/list_preferences",
                json=request_data,
                timeout=10,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"List preferences failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("List preferences timed out after 10 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during list preferences: {e}")

    async def suggest_preference(
        self,
        content: str,
        category: str,
        confidence: float,
        session_id: str,
        project_id: str | None = None,
        detection_method: str = "explicit",
        evidence: str = "",
        scope_type: str = "project",
        scope_value: str | None = None,
    ) -> dict[str, Any]:
        """Suggest a new preference for approval.

        Phase 5: Orchestration Integration
        Used for automatic preference suggestions during conflict resolution.

        Args:
            content: Preference description
            category: Preference category (style, pattern, tool, quality, workflow)
            confidence: Confidence score 0.0-1.0
            session_id: Session ID
            project_id: Optional project ID
            detection_method: Detection method (default: explicit)
            evidence: Supporting evidence
            scope_type: Scope type (global, project, language, framework)
            scope_value: Optional scope value

        Returns:
            {
                "preference_id": str,
                "status": "approved" | "pending",
                "message": str
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If required fields missing or request fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not content:
            raise RuntimeError("content is required for suggest_preference")
        if not session_id:
            raise RuntimeError("session_id is required for suggest_preference")

        try:
            request_data = {
                "content": content,
                "category": category,
                "confidence": confidence,
                "session_id": session_id,
                "detection_method": detection_method,
                "evidence": evidence,
                "scope_type": scope_type,
                "scope_value": scope_value or project_id,
            }

            if project_id:
                request_data["project_id"] = project_id

            async with self.session.post(
                f"{self.base_url}/api/suggest_preference",
                json=request_data,
                timeout=10,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Suggest preference failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Suggest preference timed out after 10 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during suggest preference: {e}")

    async def store_adr(
        self,
        decision: str,
        context: str,
        alternatives_considered: list[dict[str, str]],
        consequences: list[str],
        status: str,
        session_id: str,
        project_id: str | None = None,
        related_symbols: list[str] | None = None,
    ) -> dict[str, Any]:
        """Store an Architectural Decision Record to PRISM.

        Stores ADRs in ANCHORS tier (never expires) with full context,
        alternatives considered, and consequences.

        Args:
            decision: The decision made
            context: Context/problem being addressed
            alternatives_considered: List of alternatives with rejection reasons
                Format: [{"alternative": "X", "reason_rejected": "Y"}, ...]
            consequences: List of consequences from this decision
            status: Decision status (proposed, accepted, deprecated, superseded)
            session_id: Current session ID
            project_id: Optional project identifier
            related_symbols: Optional list of related code symbols

        Returns:
            {
                "success": bool,
                "adr_id": str,
                "message": str
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If required fields missing or request fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not decision:
            raise RuntimeError("decision is required for store_adr")
        if not context:
            raise RuntimeError("context is required for store_adr")
        if not session_id:
            raise RuntimeError("session_id is required for store_adr")

        try:
            request_data = {
                "decision": decision,
                "context": context,
                "alternatives_considered": alternatives_considered or [],
                "consequences": consequences or [],
                "status": status,
                "session_id": session_id,
            }

            if project_id:
                request_data["project_id"] = project_id
            if related_symbols:
                request_data["related_symbols"] = related_symbols

            async with self.session.post(
                f"{self.base_url}/api/adr/store",
                json=request_data,
                timeout=15,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.info(
                        f"Stored ADR to PRISM: {result.get('adr_id')} - {decision}"
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Store ADR failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Store ADR timed out after 15 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during store ADR: {e}")

    async def query_adrs(
        self,
        query: str,
        session_id: str,
        project_id: str | None = None,
        status: str | None = None,
        limit: int = 10,
    ) -> dict[str, Any]:
        """Query Architectural Decision Records from PRISM.

        Retrieves ADRs from ANCHORS tier using semantic search.

        Args:
            query: Search query (semantic search across ADR content)
            session_id: Current session ID
            project_id: Optional project filter
            status: Optional status filter (accepted, proposed, deprecated, superseded)
            limit: Maximum results (default 10)

        Returns:
            {
                "adrs": [
                    {
                        "adr_id": str,
                        "decision": str,
                        "context": str,
                        "status": str,
                        "created_at": str,
                        ...
                    },
                    ...
                ],
                "count": int
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If request fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not query:
            raise RuntimeError("query is required for query_adrs")
        if not session_id:
            raise RuntimeError("session_id is required for query_adrs")

        try:
            request_data = {
                "query": query,
                "session_id": session_id,
                "limit": limit,
            }

            if project_id:
                request_data["project_id"] = project_id
            if status:
                request_data["status"] = status

            async with self.session.post(
                f"{self.base_url}/api/adr/query",
                json=request_data,
                timeout=15,
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.debug(
                        f"Queried ADRs from PRISM: {result.get('count', 0)} results"
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Query ADRs failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError("Query ADRs timed out after 15 seconds")
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during query ADRs: {e}")

    async def detect_duplicates(
        self,
        project_path: str,
        min_lines: int = 10,
        max_results: int = 50,
    ) -> dict[str, Any]:
        """Detect code duplication across project using PRISM.

        Uses semantic similarity detection (Voyage embeddings) to find
        duplicate code patterns across the entire project.

        Args:
            project_path: Path to project root directory
            min_lines: Minimum lines to consider (ignore tiny blocks, default 10)
            max_results: Maximum duplicate groups to return (default 50)

        Returns:
            {
                "duplicates": [
                    {
                        "strategy": "extract_function",
                        "suggested_name": str,
                        "common_code": List[str],
                        "locations": List[Dict],
                        "estimated_loc_reduction": int
                    },
                    ...
                ],
                "count": int
            }

        Raises:
            ConnectionError: If PRISM is not available
            RuntimeError: If request fails
        """
        if not self._connected:
            raise ConnectionError(
                "PRISM server not connected. Call connect() first."
            )
        if not project_path:
            raise RuntimeError("project_path is required for detect_duplicates")

        try:
            request_data = {
                "project_path": project_path,
                "min_lines": min_lines,
                "max_results": max_results,
            }

            async with self.session.post(
                f"{self.base_url}/api/duplication/detect",
                json=request_data,
                timeout=120,  # Longer timeout for full project analysis
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.info(
                        f"Detected duplicates in PRISM: {result.get('count', 0)} groups found"
                    )
                    return result
                error_text = await response.text()
                raise RuntimeError(
                    f"Detect duplicates failed ({response.status}): {error_text}"
                )
        except asyncio.TimeoutError:
            raise RuntimeError(
                "Detect duplicates timed out after 120 seconds - large project may need chunking"
            )
        except aiohttp.ClientError as e:
            raise RuntimeError(f"Network error during detect duplicates: {e}")
