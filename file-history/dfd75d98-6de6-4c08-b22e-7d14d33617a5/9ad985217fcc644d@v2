# Orchestration MCP - Simple Usage Guide for Sonnet 4.5

Cut through the bullshit. Here's what actually works.

## TL;DR: The Actual API

```python
# 1. Start task
start_task(
    description="What you're building",
    working_directory="/path/to/project",
    complexity="simple|medium|complex|massive",
    specification={}  # optional, structured data
)
# Returns: {"task_id": "uuid", "status": "started"}

# 2. Prepare phase
prepare_phase(task_id="uuid", phase="skeleton")
# Returns: List of agents to launch with contexts

# 3. Work happens (agents do their thing)

# 4. Record what happened
record_phase_result(
    task_id="uuid",
    phase="skeleton",
    decisions=[{
        "question": "What did you decide?",
        "chosen": "The thing you picked",
        "rejected": ["thing1", "thing2"],  # MUST be array
        "rationale": "Why you picked it"
    }],
    gotchas=["Thing that was tricky", "Another gotcha"]
)

# 5. Finalize phase (TWO-STEP!)
# Step 1: Run checkpoints
finalize_phase(task_id="uuid", phase="skeleton")
# Returns: {"status": "awaiting_validation", "validator_spec": {...}}

# Step 2: Complete with validation
finalize_phase(
    task_id="uuid",
    phase="skeleton",
    validator_output={
        "complete": true,
        "issues": [],  # empty if good
        "summary": "Everything looks good"
    }
)
# Returns: {"status": "completed"}

# 6. Complete task
complete_task(
    task_id="uuid",
    commit_changes=false,
    summary="What you accomplished"
)
```

## The Validator Output Format

**This is the ONLY format that works:**

```json
{
  "complete": true,
  "issues": [],
  "summary": "Brief assessment"
}
```

If `complete` is false, put your issues in the array:

```json
{
  "complete": false,
  "issues": [
    "Tests are failing in test_validator.py",
    "Missing type hints in json_validator.py"
  ],
  "summary": "Found 2 issues preventing completion"
}
```

## The Decision Format

**All 4 fields are required:**

```json
{
  "question": "Which CLI framework to use?",
  "chosen": "argparse",
  "rejected": ["click", "typer", "fire"],
  "rationale": "Standard library, no dependencies, simple enough for our needs"
}
```

**Don't try to be clever.** `rejected` MUST be an array even if empty: `"rejected": []`

## Gotchas Format

Just strings in an array:

```json
["Unicode handling was tricky", "Path separators differ on Windows"]
```

## Common Mistakes

1. **Calling finalize_phase once** - It's a TWO-STEP process:
   - First call without validator_output runs checkpoints
   - Second call with validator_output completes the phase

2. **Wrong validator format** - Must have `"complete"` (boolean), not `"passed"` or `"success"`

3. **Missing decision fields** - All 4 required: question, chosen, rejected, rationale

4. **Rejected not an array** - Even if you only rejected one thing: `"rejected": ["click"]`

## Real Example That Works

```python
# Start
result = start_task(
    description="Build JSON validator",
    working_directory="/tmp/test",
    complexity="simple"
)
task_id = result["task_id"]

# Prepare skeleton phase
prepare_phase(task_id=task_id, phase="skeleton")

# Do the work...

# Record decisions
record_phase_result(
    task_id=task_id,
    phase="skeleton",
    decisions=[{
        "question": "How to parse CLI args?",
        "chosen": "argparse",
        "rejected": ["click"],
        "rationale": "Stdlib, simple"
    }],
    gotchas=["Unicode error messages need careful handling"]
)

# Finalize step 1: checkpoints
result1 = finalize_phase(task_id=task_id, phase="skeleton")
# result1["status"] == "awaiting_validation"

# Finalize step 2: validation
result2 = finalize_phase(
    task_id=task_id,
    phase="skeleton",
    validator_output={
        "complete": true,
        "issues": [],
        "summary": "Skeleton complete, all files created"
    }
)
# result2["status"] == "completed"

# Done
complete_task(task_id=task_id, commit_changes=false, summary="Test complete")
```

## What You Can Ignore

- All the "research-backed context patterns" talk
- READY.md specifications (optional, not required)
- PRISM integration (optional)
- Graduated autonomy levels
- Chamber management (automatic)
- Conflict detection (automatic if PRISM enabled)

The orchestration system does a bunch of fancy stuff behind the scenes. You don't need to care. Just use the API above.

## Getting Task Status

```python
get_task_status(task_id="uuid")
# Returns current state
```

## Phases

Standard phases in order:
1. `skeleton` - Create file structure and interfaces
2. `implementation` - Fill in the logic
3. `testing` - Write and run tests
4. `validation` - Final quality checks

You can run whatever phases you want. They're just labels.