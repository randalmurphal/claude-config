#!/usr/bin/env bash
# Smart git worktree manager
# Auto-detects repo, creates sensible worktree structure

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default configuration
DEFAULT_PREFIX="wt-"
DEFAULT_BASE_BRANCH="main"

# Print usage
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [MODULE_NAMES...]

Smart git worktree manager that auto-detects repo and creates organized worktrees.

EXAMPLES:
  $(basename "$0") auth api database       # Create 3 worktrees for modules
  $(basename "$0") --list                  # List all worktrees
  $(basename "$0") --cleanup               # Remove all worktrees
  $(basename "$0") --base /tmp/wt auth     # Custom base directory

OPTIONS:
  -l, --list              List all worktrees for this repo
  -c, --cleanup           Remove all worktrees (keeps main repo)
  -b, --base DIR          Base directory for worktrees (default: ../.worktrees/<repo-name>)
  -p, --prefix PREFIX     Prefix for worktree branches (default: wt-)
  -m, --main BRANCH       Base branch to branch from (default: main)
  -h, --help              Show this help message

WORKTREE STRUCTURE:
  Main repo:     /path/to/repo/
  Worktrees:     /path/to/.worktrees/repo/wt-auth/
                 /path/to/.worktrees/repo/wt-api/
                 /path/to/.worktrees/repo/wt-database/

WORKFLOW:
  1. Create worktrees: git-worktree auth api
  2. Work in parallel: cd ../.worktrees/repo/wt-auth
  3. Cleanup when done: git-worktree --cleanup
EOF
    exit 0
}

# Print colored message
log() {
    local color=$1
    shift
    echo -e "${color}$*${NC}"
}

# Detect git repo root
get_repo_root() {
    if ! git rev-parse --show-toplevel 2>/dev/null; then
        log "$RED" "Error: Not in a git repository"
        exit 1
    fi
}

# Get repo name
get_repo_name() {
    basename "$(get_repo_root)"
}

# Get default worktree base directory
get_default_base() {
    local repo_root
    repo_root=$(get_repo_root)
    local repo_name
    repo_name=$(get_repo_name)
    echo "$(dirname "$repo_root")/.worktrees/$repo_name"
}

# List all worktrees
list_worktrees() {
    local repo_root
    repo_root=$(get_repo_root)

    log "$BLUE" "=== Worktrees for $(get_repo_name) ==="

    git worktree list | while IFS= read -r line; do
        # Highlight main repo
        if echo "$line" | grep -q "\[main\]"; then
            log "$GREEN" "  $line (main repo)"
        else
            echo "  $line"
        fi
    done
}

# Cleanup all worktrees
cleanup_worktrees() {
    local repo_root
    repo_root=$(get_repo_root)

    log "$YELLOW" "Cleaning up worktrees for $(get_repo_name)..."

    # Get list of worktree paths (excluding main repo)
    local worktree_paths
    worktree_paths=$(git worktree list --porcelain | grep -E "^worktree " | awk '{print $2}' | grep -v "^$repo_root$" || true)

    if [[ -z "$worktree_paths" ]]; then
        log "$YELLOW" "No worktrees to cleanup"
        return 0
    fi

    # Remove each worktree
    while IFS= read -r wt_path; do
        if [[ -n "$wt_path" ]]; then
            log "$YELLOW" "  Removing worktree: $wt_path"
            git worktree remove "$wt_path" --force 2>/dev/null || true
        fi
    done <<< "$worktree_paths"

    # Prune stale references
    git worktree prune

    log "$GREEN" "✓ Cleanup complete"
}

# Create worktree for a module
create_worktree() {
    local module_name=$1
    local base_dir=$2
    local prefix=$3
    local base_branch=$4
    local repo_root
    repo_root=$(get_repo_root)

    # Worktree directory and branch name
    local wt_dir="$base_dir/$prefix$module_name"
    local branch_name="$prefix$module_name"

    # Create base directory if needed
    mkdir -p "$base_dir"

    # Check if worktree already exists
    if git worktree list | grep -q "$wt_dir"; then
        log "$YELLOW" "  Worktree already exists: $wt_dir"
        return 0
    fi

    # Check if branch exists
    local branch_exists=false
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        branch_exists=true
    fi

    # Create worktree
    if $branch_exists; then
        log "$BLUE" "  Creating worktree from existing branch: $branch_name"
        git worktree add "$wt_dir" "$branch_name"
    else
        log "$BLUE" "  Creating worktree with new branch: $branch_name (from $base_branch)"
        # Verify base branch exists
        if ! git show-ref --verify --quiet "refs/heads/$base_branch"; then
            log "$RED" "Error: Base branch '$base_branch' does not exist"
            log "$YELLOW" "Available branches:"
            git branch -a
            exit 1
        fi
        git worktree add -b "$branch_name" "$wt_dir" "$base_branch"
    fi

    log "$GREEN" "  ✓ Created: $wt_dir"
}

# Main script
main() {
    local base_dir=""
    local prefix="$DEFAULT_PREFIX"
    local base_branch="$DEFAULT_BASE_BRANCH"
    local modules=()
    local mode="create"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                ;;
            -l|--list)
                mode="list"
                shift
                ;;
            -c|--cleanup)
                mode="cleanup"
                shift
                ;;
            -b|--base)
                base_dir="$2"
                shift 2
                ;;
            -p|--prefix)
                prefix="$2"
                shift 2
                ;;
            -m|--main)
                base_branch="$2"
                shift 2
                ;;
            -*)
                log "$RED" "Unknown option: $1"
                echo
                usage
                ;;
            *)
                modules+=("$1")
                shift
                ;;
        esac
    done

    # Validate we're in a git repo
    get_repo_root >/dev/null

    # Set default base dir if not provided
    if [[ -z "$base_dir" ]]; then
        base_dir=$(get_default_base)
    fi

    # Execute mode
    case $mode in
        list)
            list_worktrees
            ;;
        cleanup)
            cleanup_worktrees
            ;;
        create)
            if [[ ${#modules[@]} -eq 0 ]]; then
                log "$RED" "Error: No module names provided"
                echo
                usage
            fi

            log "$BLUE" "Creating worktrees for $(get_repo_name)..."
            log "$BLUE" "  Base directory: $base_dir"
            log "$BLUE" "  Branch prefix: $prefix"
            log "$BLUE" "  Base branch: $base_branch"
            echo

            for module in "${modules[@]}"; do
                create_worktree "$module" "$base_dir" "$prefix" "$base_branch"
            done

            echo
            log "$GREEN" "✓ All worktrees created successfully"
            echo
            log "$YELLOW" "Next steps:"
            log "$YELLOW" "  1. cd $base_dir/$prefix${modules[0]}"
            log "$YELLOW" "  2. Make your changes"
            log "$YELLOW" "  3. Commit and merge back to $base_branch"
            log "$YELLOW" "  4. Run: $(basename "$0") --cleanup"
            ;;
    esac
}

# Run main
main "$@"
